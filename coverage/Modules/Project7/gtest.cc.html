<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>gtest.cc</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// Copyright 2005, Google Inc.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
//     * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

//
// The Google C++ Testing and Mocking Framework (Google Test)

#include "gtest/gtest.h"
#include "gtest/internal/custom/gtest.h"
#include "gtest/gtest-spi.h"

#include &lt;ctype.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
#include &lt;wchar.h&gt;
#include &lt;wctype.h&gt;

#include &lt;algorithm&gt;
#include &lt;chrono&gt;  // NOLINT
#include &lt;cmath&gt;
#include &lt;cstdint&gt;
#include &lt;iomanip&gt;
#include &lt;limits&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;ostream&gt;  // NOLINT
#include &lt;sstream&gt;
#include &lt;vector&gt;

#if GTEST_OS_LINUX

# include &lt;fcntl.h&gt;  // NOLINT
# include &lt;limits.h&gt;  // NOLINT
# include &lt;sched.h&gt;  // NOLINT
// Declares vsnprintf().  This header is not available on Windows.
# include &lt;strings.h&gt;  // NOLINT
# include &lt;sys/mman.h&gt;  // NOLINT
# include &lt;sys/time.h&gt;  // NOLINT
# include &lt;unistd.h&gt;  // NOLINT
# include &lt;string&gt;

#elif GTEST_OS_ZOS
# include &lt;sys/time.h&gt;  // NOLINT

// On z/OS we additionally need strings.h for strcasecmp.
# include &lt;strings.h&gt;  // NOLINT

#elif GTEST_OS_WINDOWS_MOBILE  // We are on Windows CE.

# include &lt;windows.h&gt;  // NOLINT
# undef min

#elif GTEST_OS_WINDOWS  // We are on Windows proper.

# include &lt;windows.h&gt;  // NOLINT
# undef min

#ifdef _MSC_VER
# include &lt;crtdbg.h&gt;  // NOLINT
#endif

# include &lt;io.h&gt;  // NOLINT
# include &lt;sys/timeb.h&gt;  // NOLINT
# include &lt;sys/types.h&gt;  // NOLINT
# include &lt;sys/stat.h&gt;  // NOLINT

# if GTEST_OS_WINDOWS_MINGW
#  include &lt;sys/time.h&gt;  // NOLINT
# endif  // GTEST_OS_WINDOWS_MINGW

#else

// cpplint thinks that the header is already included, so we want to
// silence it.
# include &lt;sys/time.h&gt;  // NOLINT
# include &lt;unistd.h&gt;  // NOLINT

#endif  // GTEST_OS_LINUX

#if GTEST_HAS_EXCEPTIONS
# include &lt;stdexcept&gt;
#endif

#if GTEST_CAN_STREAM_RESULTS_
# include &lt;arpa/inet.h&gt;  // NOLINT
# include &lt;netdb.h&gt;  // NOLINT
# include &lt;sys/socket.h&gt;  // NOLINT
# include &lt;sys/types.h&gt;  // NOLINT
#endif

#include "src/gtest-internal-inl.h"

#if GTEST_OS_WINDOWS
# define vsnprintf _vsnprintf
#endif  // GTEST_OS_WINDOWS

#if GTEST_OS_MAC
#ifndef GTEST_OS_IOS
#include &lt;crt_externs.h&gt;
#endif
#endif

#if GTEST_HAS_ABSL
#include "absl/debugging/failure_signal_handler.h"
#include "absl/debugging/stacktrace.h"
#include "absl/debugging/symbolize.h"
#include "absl/strings/str_cat.h"
#endif  // GTEST_HAS_ABSL

namespace testing {

using internal::CountIf;
using internal::ForEach;
using internal::GetElementOr;
using internal::Shuffle;

// Constants.

// A test whose test suite name or test name matches this filter is
// disabled and not run.
static const char kDisableTestFilter[] = "DISABLED_*:*/DISABLED_*";

// A test suite whose name matches this filter is considered a death
// test suite and will be run before test suites whose name doesn't
// match this filter.
static const char kDeathTestSuiteFilter[] = "*DeathTest:*DeathTest/*";

// A test filter that matches everything.
static const char kUniversalFilter[] = "*";

// The default output format.
static const char kDefaultOutputFormat[] = "xml";
// The default output file.
static const char kDefaultOutputFile[] = "test_detail";

// The environment variable name for the test shard index.
static const char kTestShardIndex[] = "GTEST_SHARD_INDEX";
// The environment variable name for the total number of test shards.
static const char kTestTotalShards[] = "GTEST_TOTAL_SHARDS";
// The environment variable name for the test shard status file.
static const char kTestShardStatusFile[] = "GTEST_SHARD_STATUS_FILE";

namespace internal {

// The text used in failure messages to indicate the start of the
// stack trace.
const char kStackTraceMarker[] = "\nStack trace:\n";

// g_help_flag is true if and only if the --help flag or an equivalent form
// is specified on the command line.
bool g_help_flag = false;

// Utilty function to Open File for Writing
<span style = "background-color:#fdd">static FILE* OpenFileForWriting(const std::string&amp; output_file) {
  FILE* fileout = nullptr;
  FilePath output_file_path(output_file);
  FilePath output_dir(output_file_path.RemoveFileName());</span>

<span style = "background-color:#fdd">  if (output_dir.CreateDirectoriesRecursively()) {
    fileout = posix::FOpen(output_file.c_str(), "w");</span>
  }
<span style = "background-color:#fdd">  if (fileout == nullptr) {
    GTEST_LOG_(FATAL) &lt;&lt; "Unable to open file \"" &lt;&lt; output_file &lt;&lt; "\"";</span>
  }
<span style = "background-color:#fdd">  return fileout;
}</span>

}  // namespace internal

// Bazel passes in the argument to '--test_filter' via the TESTBRIDGE_TEST_ONLY
// environment variable.
<span style = "background-color:#dfd">static const char* GetDefaultFilter() {
  const char* const testbridge_test_only =</span>
      internal::posix::GetEnv("TESTBRIDGE_TEST_ONLY");
<span style = "background-color:#dfd">  if (testbridge_test_only != nullptr) {</span>
<span style = "background-color:#fdd">    return testbridge_test_only;</span>
  }
<span style = "background-color:#dfd">  return kUniversalFilter;
}</span>

// Bazel passes in the argument to '--test_runner_fail_fast' via the
// TESTBRIDGE_TEST_RUNNER_FAIL_FAST environment variable.
<span style = "background-color:#dfd">static bool GetDefaultFailFast() {
  const char* const testbridge_test_runner_fail_fast =</span>
      internal::posix::GetEnv("TESTBRIDGE_TEST_RUNNER_FAIL_FAST");
<span style = "background-color:#dfd">  if (testbridge_test_runner_fail_fast != nullptr) {</span>
<span style = "background-color:#fdd">    return strcmp(testbridge_test_runner_fail_fast, "1") == 0;</span>
  }
<span style = "background-color:#dfd">  return false;
}</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    fail_fast, internal::BoolFromGTestEnv("fail_fast", GetDefaultFailFast()),
<span style = "background-color:#dfd">    "True if and only if a test failure should stop further test execution.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    also_run_disabled_tests,
    internal::BoolFromGTestEnv("also_run_disabled_tests", false),
<span style = "background-color:#dfd">    "Run disabled tests too, in addition to the tests normally being run.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    break_on_failure, internal::BoolFromGTestEnv("break_on_failure", false),
    "True if and only if a failed assertion should be a debugger "
<span style = "background-color:#dfd">    "break-point.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(catch_exceptions,</span>
                   internal::BoolFromGTestEnv("catch_exceptions", true),
                   "True if and only if " GTEST_NAME_
<span style = "background-color:#dfd">                   " should catch exceptions and treat them as test failures.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_string_(</span>
    color,
    internal::StringFromGTestEnv("color", "auto"),
    "Whether to use colors in the output.  Valid values: yes, no, "
    "and auto.  'auto' means to use colors if the output is "
    "being sent to a terminal and the TERM environment variable "
<span style = "background-color:#dfd">    "is set to a terminal type that supports colors.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_string_(</span>
    filter,
    internal::StringFromGTestEnv("filter", GetDefaultFilter()),
    "A colon-separated list of glob (not regex) patterns "
    "for filtering the tests to run, optionally followed by a "
    "'-' and a : separated list of negative patterns (tests to "
    "exclude).  A test is run if it matches one of the positive "
<span style = "background-color:#dfd">    "patterns and does not match any of the negative patterns.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    install_failure_signal_handler,
    internal::BoolFromGTestEnv("install_failure_signal_handler", false),
    "If true and supported on the current platform, " GTEST_NAME_ " should "
    "install a signal handler that dumps debugging information when fatal "
<span style = "background-color:#dfd">    "signals are raised.");</span>

GTEST_DEFINE_bool_(list_tests, false,
                   "List all tests without running them.");

// The net priority order after flag processing is thus:
//   --gtest_output command line flag
//   GTEST_OUTPUT environment variable
//   XML_OUTPUT_FILE environment variable
//   ''
<span style = "background-color:#dfd">GTEST_DEFINE_string_(</span>
    output,
    internal::StringFromGTestEnv("output",
      internal::OutputFlagAlsoCheckEnvVar().c_str()),
    "A format (defaults to \"xml\" but can be specified to be \"json\"), "
    "optionally followed by a colon and an output file name or directory. "
    "A directory is indicated by a trailing pathname separator. "
    "Examples: \"xml:filename.xml\", \"xml::directoryname/\". "
    "If a directory is specified, output files will be created "
    "within that directory, with file-names based on the test "
    "executable's name and, if necessary, made unique by adding "
<span style = "background-color:#dfd">    "digits.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    brief, internal::BoolFromGTestEnv("brief", false),
<span style = "background-color:#dfd">    "True if only test failures should be displayed in text output.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(print_time, internal::BoolFromGTestEnv("print_time", true),</span>
                   "True if and only if " GTEST_NAME_
<span style = "background-color:#dfd">                   " should display elapsed time in text output.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(print_utf8, internal::BoolFromGTestEnv("print_utf8", true),</span>
                   "True if and only if " GTEST_NAME_
<span style = "background-color:#dfd">                   " prints UTF8 characters as text.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_int32_(</span>
    random_seed,
    internal::Int32FromGTestEnv("random_seed", 0),
    "Random number seed to use when shuffling test orders.  Must be in range "
<span style = "background-color:#dfd">    "[1, 99999], or 0 to use a seed based on the current time.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_int32_(</span>
    repeat,
    internal::Int32FromGTestEnv("repeat", 1),
    "How many times to repeat each test.  Specify a negative number "
<span style = "background-color:#dfd">    "for repeating forever.  Useful for shaking out flaky tests.");</span>

GTEST_DEFINE_bool_(show_internal_stack_frames, false,
                   "True if and only if " GTEST_NAME_
                   " should include internal stack frames when "
                   "printing test failure stack traces.");

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(shuffle, internal::BoolFromGTestEnv("shuffle", false),</span>
                   "True if and only if " GTEST_NAME_
<span style = "background-color:#dfd">                   " should randomize tests' order on every run.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_int32_(</span>
    stack_trace_depth,
    internal::Int32FromGTestEnv("stack_trace_depth", kMaxStackTraceDepth),
    "The maximum number of stack frames to print when an "
<span style = "background-color:#dfd">    "assertion fails.  The valid range is 0 through 100, inclusive.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_string_(</span>
    stream_result_to,
    internal::StringFromGTestEnv("stream_result_to", ""),
    "This flag specifies the host name and the port number on which to stream "
    "test results. Example: \"localhost:555\". The flag is effective only on "
<span style = "background-color:#dfd">    "Linux.");</span>

<span style = "background-color:#dfd">GTEST_DEFINE_bool_(</span>
    throw_on_failure,
    internal::BoolFromGTestEnv("throw_on_failure", false),
    "When this flag is specified, a failed assertion will throw an exception "
    "if exceptions are enabled or exit the program with a non-zero code "
<span style = "background-color:#dfd">    "otherwise. For use with an external test framework.");</span>

#if GTEST_USE_OWN_FLAGFILE_FLAG_
<span style = "background-color:#dfd">GTEST_DEFINE_string_(</span>
    flagfile,
    internal::StringFromGTestEnv("flagfile", ""),
<span style = "background-color:#dfd">    "This flag specifies the flagfile to read command-line flags from.");</span>
#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_

namespace internal {

// Generates a random number from [0, range), using a Linear
// Congruential Generator (LCG).  Crashes if 'range' is 0 or greater
// than kMaxRange.
<span style = "background-color:#fdd">uint32_t Random::Generate(uint32_t range) {</span>
  // These constants are the same as are used in glibc's rand(3).
  // Use wider types than necessary to prevent unsigned overflow diagnostics.
<span style = "background-color:#fdd">  state_ = static_cast&lt;uint32_t&gt;(1103515245ULL*state_ + 12345U) % kMaxRange;</span>

<span style = "background-color:#fdd">  GTEST_CHECK_(range &gt; 0)</span>
      &lt;&lt; "Cannot generate a number in the range [0, 0).";
<span style = "background-color:#fdd">  GTEST_CHECK_(range &lt;= kMaxRange)</span>
      &lt;&lt; "Generation of a number in [0, " &lt;&lt; range &lt;&lt; ") was requested, "
      &lt;&lt; "but this can only generate numbers in [0, " &lt;&lt; kMaxRange &lt;&lt; ").";

  // Converting via modulus introduces a bit of downward bias, but
  // it's simple, and a linear congruential generator isn't too good
  // to begin with.
<span style = "background-color:#fdd">  return state_ % range;
}</span>

// GTestIsInitialized() returns true if and only if the user has initialized
// Google Test.  Useful for catching the user mistake of not initializing
// Google Test before calling RUN_ALL_TESTS().
<span style = "background-color:#dfd">static bool GTestIsInitialized() { return GetArgvs().size() &gt; 0; }</span>

// Iterates over a vector of TestSuites, keeping a running sum of the
// results of calling a given int-returning method on each.
// Returns the sum.
static int SumOverTestSuiteList(const std::vector&lt;TestSuite*&gt;&amp; case_list,
<span style = "background-color:#dfd">                                int (TestSuite::*method)() const) {
  int sum = 0;
  for (size_t i = 0; i &lt; case_list.size(); i++) {
    sum += (case_list[i]-&gt;*method)();
  }
  return sum;
}</span>

// Returns true if and only if the test suite passed.
<span style = "background-color:#fdd">static bool TestSuitePassed(const TestSuite* test_suite) {
  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Passed();
}</span>

// Returns true if and only if the test suite failed.
<span style = "background-color:#dfd">static bool TestSuiteFailed(const TestSuite* test_suite) {
  return test_suite-&gt;should_run() &amp;&amp; test_suite-&gt;Failed();
}</span>

// Returns true if and only if test_suite contains at least one test that
// should run.
<span style = "background-color:#dfd">static bool ShouldRunTestSuite(const TestSuite* test_suite) {
  return test_suite-&gt;should_run();
}</span>

// AssertHelper constructor.
AssertHelper::AssertHelper(TestPartResult::Type type,
                           const char* file,
                           int line,
                           const char* message)
<span style = "background-color:#fdd">    : data_(new AssertHelperData(type, file, line, message)) {
}</span>

<span style = "background-color:#fdd">AssertHelper::~AssertHelper() {
  delete data_;
}</span>

// Message assignment, for assertion streaming support.
<span style = "background-color:#fdd">void AssertHelper::operator=(const Message&amp; message) const {
  UnitTest::GetInstance()-&gt;</span>
    AddTestPartResult(data_-&gt;type, data_-&gt;file, data_-&gt;line,
                      AppendUserMessage(data_-&gt;message, message),
                      UnitTest::GetInstance()-&gt;impl()
                      -&gt;CurrentOsStackTraceExceptTop(1)
                      // Skips the stack frame for this function itself.
                      );  // NOLINT
<span style = "background-color:#fdd">}</span>

namespace {

// When TEST_P is found without a matching INSTANTIATE_TEST_SUITE_P
// to creates test cases for it, a syntetic test case is
// inserted to report ether an error or a log message.
//
// This configuration bit will likely be removed at some point.
constexpr bool kErrorOnUninstantiatedParameterizedTest = true;
constexpr bool kErrorOnUninstantiatedTypeParameterizedTest = true;

// A test that fails at a given file/line location with a given message.
class FailureTest : public Test {
 public:
  explicit FailureTest(const CodeLocation&amp; loc, std::string error_message,
                       bool as_error)
<span style = "background-color:#fdd">      : loc_(loc),
        error_message_(std::move(error_message)),
        as_error_(as_error) {}</span>

<span style = "background-color:#fdd">  void TestBody() override {
    if (as_error_) {
      AssertHelper(TestPartResult::kNonFatalFailure, loc_.file.c_str(),</span>
                   loc_.line, "") = Message() &lt;&lt; error_message_;
<span style = "background-color:#fdd">    } else {
      std::cout &lt;&lt; error_message_ &lt;&lt; std::endl;</span>
    }
<span style = "background-color:#fdd">  }</span>

 private:
  const CodeLocation loc_;
  const std::string error_message_;
  const bool as_error_;
};


}  // namespace

<span style = "background-color:#dfd">std::set&lt;std::string&gt;* GetIgnoredParameterizedTestSuites() {
  return UnitTest::GetInstance()-&gt;impl()-&gt;ignored_parameterized_test_suites();
}</span>

// Add a given test_suit to the list of them allow to go un-instantiated.
<span style = "background-color:#fdd">MarkAsIgnored::MarkAsIgnored(const char* test_suite) {
  GetIgnoredParameterizedTestSuites()-&gt;insert(test_suite);
}</span>

// If this parameterized test suite has no instantiations (and that
// has not been marked as okay), emit a test case reporting that.
void InsertSyntheticTestCase(const std::string&amp; name, CodeLocation location,
<span style = "background-color:#fdd">                             bool has_test_p) {
  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();
  if (ignored.find(name) != ignored.end()) return;</span>

<span style = "background-color:#fdd">  const char kMissingInstantiation[] =  //</span>
      " is defined via TEST_P, but never instantiated. None of the test cases "
      "will run. Either no INSTANTIATE_TEST_SUITE_P is provided or the only "
      "ones provided expand to nothing."
      "\n\n"
      "Ideally, TEST_P definitions should only ever be included as part of "
      "binaries that intend to use them. (As opposed to, for example, being "
      "placed in a library that may be linked in to get other utilities.)";

<span style = "background-color:#fdd">  const char kMissingTestCase[] =  //</span>
      " is instantiated via INSTANTIATE_TEST_SUITE_P, but no tests are "
      "defined via TEST_P . No test cases will run."
      "\n\n"
      "Ideally, INSTANTIATE_TEST_SUITE_P should only ever be invoked from "
      "code that always depend on code that provides TEST_P. Failing to do "
      "so is often an indication of dead code, e.g. the last TEST_P was "
      "removed but the rest got left behind.";

<span style = "background-color:#fdd">  std::string message =</span>
      "Parameterized test suite " + name +
      (has_test_p ? kMissingInstantiation : kMissingTestCase) +
      "\n\n"
      "To suppress this error for this test suite, insert the following line "
      "(in a non-header) in the namespace it is defined in:"
      "\n\n"
      "GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(" + name + ");";

<span style = "background-color:#fdd">  std::string full_name = "UninstantiatedParameterizedTestSuite&lt;" + name + "&gt;";
  RegisterTest(  //</span>
      "GoogleTestVerification", full_name.c_str(),
      nullptr,  // No type parameter.
      nullptr,  // No value parameter.
<span style = "background-color:#fdd">      location.file.c_str(), location.line, [message, location] {
        return new FailureTest(location, message,</span>
                               kErrorOnUninstantiatedParameterizedTest);
<span style = "background-color:#fdd">      });
}</span>

void RegisterTypeParameterizedTestSuite(const char* test_suite_name,
<span style = "background-color:#fdd">                                        CodeLocation code_location) {
  GetUnitTestImpl()-&gt;type_parameterized_test_registry().RegisterTestSuite(</span>
      test_suite_name, code_location);
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void RegisterTypeParameterizedTestSuiteInstantiation(const char* case_name) {
  GetUnitTestImpl()</span>
      -&gt;type_parameterized_test_registry()
      .RegisterInstantiation(case_name);
<span style = "background-color:#fdd">}</span>

void TypeParameterizedTestSuiteRegistry::RegisterTestSuite(
<span style = "background-color:#fdd">    const char* test_suite_name, CodeLocation code_location) {
  suites_.emplace(std::string(test_suite_name),</span>
                 TypeParameterizedTestSuiteInfo(code_location));
<span style = "background-color:#fdd">}</span>

void TypeParameterizedTestSuiteRegistry::RegisterInstantiation(
<span style = "background-color:#fdd">        const char* test_suite_name) {
  auto it = suites_.find(std::string(test_suite_name));
  if (it != suites_.end()) {
    it-&gt;second.instantiated = true;
  } else {
    GTEST_LOG_(ERROR) &lt;&lt; "Unknown type parameterized test suit '"</span>
                      &lt;&lt; test_suite_name &lt;&lt; "'";
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#dfd">void TypeParameterizedTestSuiteRegistry::CheckForInstantiations() {
  const auto&amp; ignored = *GetIgnoredParameterizedTestSuites();
  for (const auto&amp; testcase : suites_) {</span>
<span style = "background-color:#fdd">    if (testcase.second.instantiated) continue;
    if (ignored.find(testcase.first) != ignored.end()) continue;</span>

<span style = "background-color:#fdd">    std::string message =</span>
        "Type parameterized test suite " + testcase.first +
        " is defined via REGISTER_TYPED_TEST_SUITE_P, but never instantiated "
        "via INSTANTIATE_TYPED_TEST_SUITE_P. None of the test cases will run."
        "\n\n"
        "Ideally, TYPED_TEST_P definitions should only ever be included as "
        "part of binaries that intend to use them. (As opposed to, for "
        "example, being placed in a library that may be linked in to get other "
        "utilities.)"
        "\n\n"
        "To suppress this error for this test suite, insert the following line "
        "(in a non-header) in the namespace it is defined in:"
        "\n\n"
        "GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(" +
        testcase.first + ");";

<span style = "background-color:#fdd">    std::string full_name =</span>
        "UninstantiatedTypeParameterizedTestSuite&lt;" + testcase.first + "&gt;";
<span style = "background-color:#fdd">    RegisterTest(  //</span>
        "GoogleTestVerification", full_name.c_str(),
        nullptr,  // No type parameter.
        nullptr,  // No value parameter.
        testcase.second.code_location.file.c_str(),
<span style = "background-color:#fdd">        testcase.second.code_location.line, [message, testcase] {
          return new FailureTest(testcase.second.code_location, message,</span>
                                 kErrorOnUninstantiatedTypeParameterizedTest);
<span style = "background-color:#fdd">        });
  }</span>
<span style = "background-color:#dfd">}</span>

// A copy of all command line arguments.  Set by InitGoogleTest().
<span style = "background-color:#dfd">static ::std::vector&lt;std::string&gt; g_argvs;</span>

<span style = "background-color:#dfd">::std::vector&lt;std::string&gt; GetArgvs() {</span>
#if defined(GTEST_CUSTOM_GET_ARGVS_)
  // GTEST_CUSTOM_GET_ARGVS_() may return a container of std::string or
  // ::string. This code converts it to the appropriate type.
  const auto&amp; custom = GTEST_CUSTOM_GET_ARGVS_();
  return ::std::vector&lt;std::string&gt;(custom.begin(), custom.end());
#else   // defined(GTEST_CUSTOM_GET_ARGVS_)
<span style = "background-color:#dfd">  return g_argvs;</span>
#endif  // defined(GTEST_CUSTOM_GET_ARGVS_)
<span style = "background-color:#dfd">}</span>

// Returns the current application's name, removing directory path if that
// is present.
<span style = "background-color:#fdd">FilePath GetCurrentExecutableName() {
  FilePath result;</span>

#if GTEST_OS_WINDOWS || GTEST_OS_OS2
<span style = "background-color:#fdd">  result.Set(FilePath(GetArgvs()[0]).RemoveExtension("exe"));</span>
#else
  result.Set(FilePath(GetArgvs()[0]));
#endif  // GTEST_OS_WINDOWS

<span style = "background-color:#fdd">  return result.RemoveDirectoryName();
}</span>

// Functions for processing the gtest_output flag.

// Returns the output format, or "" for normal printed output.
<span style = "background-color:#dfd">std::string UnitTestOptions::GetOutputFormat() {
  const char* const gtest_output_flag = GTEST_FLAG(output).c_str();
  const char* const colon = strchr(gtest_output_flag, ':');
  return (colon == nullptr)</span>
             ? std::string(gtest_output_flag)
             : std::string(gtest_output_flag,
                           static_cast&lt;size_t&gt;(colon - gtest_output_flag));
<span style = "background-color:#dfd">}</span>

// Returns the name of the requested output file, or the default if none
// was explicitly specified.
<span style = "background-color:#fdd">std::string UnitTestOptions::GetAbsolutePathToOutputFile() {
  const char* const gtest_output_flag = GTEST_FLAG(output).c_str();</span>

<span style = "background-color:#fdd">  std::string format = GetOutputFormat();
  if (format.empty())
    format = std::string(kDefaultOutputFormat);</span>

<span style = "background-color:#fdd">  const char* const colon = strchr(gtest_output_flag, ':');
  if (colon == nullptr)
    return internal::FilePath::MakeFileName(</span>
        internal::FilePath(
            UnitTest::GetInstance()-&gt;original_working_dir()),
        internal::FilePath(kDefaultOutputFile), 0,
        format.c_str()).string();

<span style = "background-color:#fdd">  internal::FilePath output_name(colon + 1);
  if (!output_name.IsAbsolutePath())
    output_name = internal::FilePath::ConcatPaths(</span>
        internal::FilePath(UnitTest::GetInstance()-&gt;original_working_dir()),
        internal::FilePath(colon + 1));

<span style = "background-color:#fdd">  if (!output_name.IsDirectory())
    return output_name.string();</span>

<span style = "background-color:#fdd">  internal::FilePath result(internal::FilePath::GenerateUniqueFileName(</span>
      output_name, internal::GetCurrentExecutableName(),
      GetOutputFormat().c_str()));
<span style = "background-color:#fdd">  return result.string();
}</span>

// Returns true if and only if the wildcard pattern matches the string. Each
// pattern consists of regular characters, single-character wildcards (?), and
// multi-character wildcards (*).
//
// This function implements a linear-time string globbing algorithm based on
// https://research.swtch.com/glob.
static bool PatternMatchesString(const std::string&amp; name_str,
<span style = "background-color:#dfd">                                 const char* pattern, const char* pattern_end) {
  const char* name = name_str.c_str();
  const char* const name_begin = name;
  const char* const name_end = name + name_str.size();</span>

<span style = "background-color:#dfd">  const char* pattern_next = pattern;
  const char* name_next = name;</span>

<span style = "background-color:#dfd">  while (pattern &lt; pattern_end || name &lt; name_end) {
    if (pattern &lt; pattern_end) {
      switch (*pattern) {</span>
        default:  // Match an ordinary character.
<span style = "background-color:#dfd">          if (name &lt; name_end &amp;&amp; *name == *pattern) {</span>
<span style = "background-color:#fdd">            ++pattern;
            ++name;
            continue;</span>
          }
<span style = "background-color:#dfd">          break;</span>
        case '?':  // Match any single character.
<span style = "background-color:#fdd">          if (name &lt; name_end) {
            ++pattern;
            ++name;
            continue;</span>
          }
<span style = "background-color:#fdd">          break;</span>
        case '*':
          // Match zero or more characters. Start by skipping over the wildcard
          // and matching zero characters from name. If that fails, restart and
          // match one more character than the last attempt.
<span style = "background-color:#dfd">          pattern_next = pattern;
          name_next = name + 1;
          ++pattern;
          continue;</span>
      }
    }
    // Failed to match a character. Restart if possible.
<span style = "background-color:#dfd">    if (name_begin &lt; name_next &amp;&amp; name_next &lt;= name_end) {
      pattern = pattern_next;
      name = name_next;
      continue;</span>
    }
<span style = "background-color:#dfd">    return false;</span>
<span style = "background-color:#fdd">  }</span>
<span style = "background-color:#dfd">  return true;
}</span>

bool UnitTestOptions::MatchesFilter(const std::string&amp; name_str,
<span style = "background-color:#dfd">                                    const char* filter) {</span>
  // The filter is a list of patterns separated by colons (:).
<span style = "background-color:#dfd">  const char* pattern = filter;
  while (true) {</span>
    // Find the bounds of this pattern.
<span style = "background-color:#dfd">    const char* const next_sep = strchr(pattern, ':');
    const char* const pattern_end =</span>
        next_sep != nullptr ? next_sep : pattern + strlen(pattern);

    // Check if this pattern matches name_str.
<span style = "background-color:#dfd">    if (PatternMatchesString(name_str, pattern, pattern_end)) {
      return true;</span>
    }

    // Give up on this pattern. However, if we found a pattern separator (:),
    // advance to the next pattern (skipping over the separator) and restart.
<span style = "background-color:#dfd">    if (next_sep == nullptr) {
      return false;</span>
    }
<span style = "background-color:#dfd">    pattern = next_sep + 1;
  }</span>
<span style = "background-color:#fdd">  return true;</span>
<span style = "background-color:#dfd">}</span>

// Returns true if and only if the user-specified filter matches the test
// suite name and the test name.
bool UnitTestOptions::FilterMatchesTest(const std::string&amp; test_suite_name,
<span style = "background-color:#dfd">                                        const std::string&amp; test_name) {
  const std::string&amp; full_name = test_suite_name + "." + test_name.c_str();</span>

  // Split --gtest_filter at '-', if there is one, to separate into
  // positive filter and negative filter portions
<span style = "background-color:#dfd">  const char* const p = GTEST_FLAG(filter).c_str();
  const char* const dash = strchr(p, '-');
  std::string positive;
  std::string negative;
  if (dash == nullptr) {
    positive = GTEST_FLAG(filter).c_str();  // Whole string is a positive filter
    negative = "";
  } else {</span>
<span style = "background-color:#fdd">    positive = std::string(p, dash);   // Everything up to the dash
    negative = std::string(dash + 1);  // Everything after the dash
    if (positive.empty()) {</span>
      // Treat '-test1' as the same as '*-test1'
<span style = "background-color:#fdd">      positive = kUniversalFilter;</span>
    }
  }

  // A filter is a colon-separated list of patterns.  It matches a
  // test if any pattern in it matches the test.
<span style = "background-color:#dfd">  return (MatchesFilter(full_name, positive.c_str()) &amp;&amp;</span>
          !MatchesFilter(full_name, negative.c_str()));
<span style = "background-color:#dfd">}</span>

#if GTEST_HAS_SEH
// Returns EXCEPTION_EXECUTE_HANDLER if Google Test should handle the
// given SEH exception, or EXCEPTION_CONTINUE_SEARCH otherwise.
// This function is useful as an __except condition.
<span style = "background-color:#fdd">int UnitTestOptions::GTestShouldProcessSEH(DWORD exception_code) {</span>
  // Google Test should handle a SEH exception if:
  //   1. the user wants it to, AND
  //   2. this is not a breakpoint exception, AND
  //   3. this is not a C++ exception (VC++ implements them via SEH,
  //      apparently).
  //
  // SEH exception code for C++ exceptions.
  // (see http://support.microsoft.com/kb/185294 for more information).
<span style = "background-color:#fdd">  const DWORD kCxxExceptionCode = 0xe06d7363;</span>

<span style = "background-color:#fdd">  bool should_handle = true;</span>

<span style = "background-color:#fdd">  if (!GTEST_FLAG(catch_exceptions))
    should_handle = false;
  else if (exception_code == EXCEPTION_BREAKPOINT)
    should_handle = false;
  else if (exception_code == kCxxExceptionCode)
    should_handle = false;</span>

<span style = "background-color:#fdd">  return should_handle ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
}</span>
#endif  // GTEST_HAS_SEH

}  // namespace internal

// The c'tor sets this object as the test part result reporter used by
// Google Test.  The 'result' parameter specifies where to report the
// results. Intercepts only failures from the current thread.
ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
    TestPartResultArray* result)
<span style = "background-color:#fdd">    : intercept_mode_(INTERCEPT_ONLY_CURRENT_THREAD),
      result_(result) {
  Init();
}</span>

// The c'tor sets this object as the test part result reporter used by
// Google Test.  The 'result' parameter specifies where to report the
// results.
ScopedFakeTestPartResultReporter::ScopedFakeTestPartResultReporter(
    InterceptMode intercept_mode, TestPartResultArray* result)
<span style = "background-color:#fdd">    : intercept_mode_(intercept_mode),
      result_(result) {
  Init();
}</span>

<span style = "background-color:#fdd">void ScopedFakeTestPartResultReporter::Init() {
  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
    old_reporter_ = impl-&gt;GetGlobalTestPartResultReporter();
    impl-&gt;SetGlobalTestPartResultReporter(this);
  } else {
    old_reporter_ = impl-&gt;GetTestPartResultReporterForCurrentThread();
    impl-&gt;SetTestPartResultReporterForCurrentThread(this);</span>
  }
<span style = "background-color:#fdd">}</span>

// The d'tor restores the test part result reporter used by Google Test
// before.
<span style = "background-color:#fdd">ScopedFakeTestPartResultReporter::~ScopedFakeTestPartResultReporter() {
  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  if (intercept_mode_ == INTERCEPT_ALL_THREADS) {
    impl-&gt;SetGlobalTestPartResultReporter(old_reporter_);
  } else {
    impl-&gt;SetTestPartResultReporterForCurrentThread(old_reporter_);</span>
  }
<span style = "background-color:#fdd">}</span>

// Increments the test part result count and remembers the result.
// This method is from the TestPartResultReporterInterface interface.
void ScopedFakeTestPartResultReporter::ReportTestPartResult(
<span style = "background-color:#fdd">    const TestPartResult&amp; result) {
  result_-&gt;Append(result);
}</span>

namespace internal {

// Returns the type ID of ::testing::Test.  We should always call this
// instead of GetTypeId&lt; ::testing::Test&gt;() to get the type ID of
// testing::Test.  This is to work around a suspected linker bug when
// using Google Test as a framework on Mac OS X.  The bug causes
// GetTypeId&lt; ::testing::Test&gt;() to return different values depending
// on whether the call is from the Google Test framework itself or
// from user test code.  GetTestTypeId() is guaranteed to always
// return the same value, as it always calls GetTypeId&lt;&gt;() from the
// gtest.cc, which is within the Google Test framework.
<span style = "background-color:#dfd">TypeId GetTestTypeId() {
  return GetTypeId&lt;Test&gt;();
}</span>

// The value of GetTestTypeId() as seen from within the Google Test
// library.  This is solely for testing GetTestTypeId().
<span style = "background-color:#dfd">extern const TypeId kTestTypeIdInGoogleTest = GetTestTypeId();</span>

// This predicate-formatter checks that 'results' contains a test part
// failure of the given type and that the failure message contains the
// given substring.
static AssertionResult HasOneFailure(const char* /* results_expr */,
                                     const char* /* type_expr */,
                                     const char* /* substr_expr */,
                                     const TestPartResultArray&amp; results,
                                     TestPartResult::Type type,
<span style = "background-color:#fdd">                                     const std::string&amp; substr) {
  const std::string expected(type == TestPartResult::kFatalFailure ?</span>
                        "1 fatal failure" :
                        "1 non-fatal failure");
<span style = "background-color:#fdd">  Message msg;
  if (results.size() != 1) {
    msg &lt;&lt; "Expected: " &lt;&lt; expected &lt;&lt; "\n"</span>
        &lt;&lt; "  Actual: " &lt;&lt; results.size() &lt;&lt; " failures";
<span style = "background-color:#fdd">    for (int i = 0; i &lt; results.size(); i++) {
      msg &lt;&lt; "\n" &lt;&lt; results.GetTestPartResult(i);
    }
    return AssertionFailure() &lt;&lt; msg;</span>
  }

<span style = "background-color:#fdd">  const TestPartResult&amp; r = results.GetTestPartResult(0);
  if (r.type() != type) {
    return AssertionFailure() &lt;&lt; "Expected: " &lt;&lt; expected &lt;&lt; "\n"</span>
                              &lt;&lt; "  Actual:\n"
                              &lt;&lt; r;
  }

<span style = "background-color:#fdd">  if (strstr(r.message(), substr.c_str()) == nullptr) {
    return AssertionFailure() &lt;&lt; "Expected: " &lt;&lt; expected &lt;&lt; " containing \""</span>
                              &lt;&lt; substr &lt;&lt; "\"\n"
                              &lt;&lt; "  Actual:\n"
                              &lt;&lt; r;
  }

<span style = "background-color:#fdd">  return AssertionSuccess();
}</span>

// The constructor of SingleFailureChecker remembers where to look up
// test part results, what type of failure we expect, and what
// substring the failure message should contain.
SingleFailureChecker::SingleFailureChecker(const TestPartResultArray* results,
                                           TestPartResult::Type type,
                                           const std::string&amp; substr)
<span style = "background-color:#fdd">    : results_(results), type_(type), substr_(substr) {}</span>

// The destructor of SingleFailureChecker verifies that the given
// TestPartResultArray contains exactly one failure that has the given
// type and contains the given substring.  If that's not the case, a
// non-fatal failure will be generated.
<span style = "background-color:#fdd">SingleFailureChecker::~SingleFailureChecker() {
  EXPECT_PRED_FORMAT3(HasOneFailure, *results_, type_, substr_);
}</span>

DefaultGlobalTestPartResultReporter::DefaultGlobalTestPartResultReporter(
<span style = "background-color:#dfd">    UnitTestImpl* unit_test) : unit_test_(unit_test) {}</span>

void DefaultGlobalTestPartResultReporter::ReportTestPartResult(
<span style = "background-color:#fdd">    const TestPartResult&amp; result) {
  unit_test_-&gt;current_test_result()-&gt;AddTestPartResult(result);
  unit_test_-&gt;listeners()-&gt;repeater()-&gt;OnTestPartResult(result);
}</span>

DefaultPerThreadTestPartResultReporter::DefaultPerThreadTestPartResultReporter(
<span style = "background-color:#dfd">    UnitTestImpl* unit_test) : unit_test_(unit_test) {}</span>

void DefaultPerThreadTestPartResultReporter::ReportTestPartResult(
<span style = "background-color:#fdd">    const TestPartResult&amp; result) {
  unit_test_-&gt;GetGlobalTestPartResultReporter()-&gt;ReportTestPartResult(result);
}</span>

// Returns the global test part result reporter.
TestPartResultReporterInterface*
<span style = "background-color:#fdd">UnitTestImpl::GetGlobalTestPartResultReporter() {
  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);
  return global_test_part_result_repoter_;
}</span>

// Sets the global test part result reporter.
void UnitTestImpl::SetGlobalTestPartResultReporter(
<span style = "background-color:#fdd">    TestPartResultReporterInterface* reporter) {
  internal::MutexLock lock(&amp;global_test_part_result_reporter_mutex_);
  global_test_part_result_repoter_ = reporter;
}</span>

// Returns the test part result reporter for the current thread.
TestPartResultReporterInterface*
<span style = "background-color:#fdd">UnitTestImpl::GetTestPartResultReporterForCurrentThread() {
  return per_thread_test_part_result_reporter_.get();
}</span>

// Sets the test part result reporter for the current thread.
void UnitTestImpl::SetTestPartResultReporterForCurrentThread(
<span style = "background-color:#fdd">    TestPartResultReporterInterface* reporter) {
  per_thread_test_part_result_reporter_.set(reporter);
}</span>

// Gets the number of successful test suites.
<span style = "background-color:#fdd">int UnitTestImpl::successful_test_suite_count() const {
  return CountIf(test_suites_, TestSuitePassed);
}</span>

// Gets the number of failed test suites.
<span style = "background-color:#dfd">int UnitTestImpl::failed_test_suite_count() const {
  return CountIf(test_suites_, TestSuiteFailed);
}</span>

// Gets the number of all test suites.
<span style = "background-color:#dfd">int UnitTestImpl::total_test_suite_count() const {
  return static_cast&lt;int&gt;(test_suites_.size());
}</span>

// Gets the number of all test suites that contain at least one test
// that should run.
<span style = "background-color:#dfd">int UnitTestImpl::test_suite_to_run_count() const {
  return CountIf(test_suites_, ShouldRunTestSuite);
}</span>

// Gets the number of successful tests.
<span style = "background-color:#dfd">int UnitTestImpl::successful_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::successful_test_count);
}</span>

// Gets the number of skipped tests.
<span style = "background-color:#dfd">int UnitTestImpl::skipped_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::skipped_test_count);
}</span>

// Gets the number of failed tests.
<span style = "background-color:#fdd">int UnitTestImpl::failed_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::failed_test_count);
}</span>

// Gets the number of disabled tests that will be reported in the XML report.
<span style = "background-color:#dfd">int UnitTestImpl::reportable_disabled_test_count() const {
  return SumOverTestSuiteList(test_suites_,</span>
                              &amp;TestSuite::reportable_disabled_test_count);
<span style = "background-color:#dfd">}</span>

// Gets the number of disabled tests.
<span style = "background-color:#fdd">int UnitTestImpl::disabled_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::disabled_test_count);
}</span>

// Gets the number of tests to be printed in the XML report.
<span style = "background-color:#fdd">int UnitTestImpl::reportable_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::reportable_test_count);
}</span>

// Gets the number of all tests.
<span style = "background-color:#fdd">int UnitTestImpl::total_test_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::total_test_count);
}</span>

// Gets the number of tests that should run.
<span style = "background-color:#dfd">int UnitTestImpl::test_to_run_count() const {
  return SumOverTestSuiteList(test_suites_, &amp;TestSuite::test_to_run_count);
}</span>

// Returns the current OS stack trace as an std::string.
//
// The maximum number of stack frames to be included is specified by
// the gtest_stack_trace_depth flag.  The skip_count parameter
// specifies the number of top frames to be skipped, which doesn't
// count against the number of frames to be included.
//
// For example, if Foo() calls Bar(), which in turn calls
// CurrentOsStackTraceExceptTop(1), Foo() will be included in the
// trace but Bar() and CurrentOsStackTraceExceptTop() won't.
<span style = "background-color:#fdd">std::string UnitTestImpl::CurrentOsStackTraceExceptTop(int skip_count) {
  return os_stack_trace_getter()-&gt;CurrentStackTrace(</span>
      static_cast&lt;int&gt;(GTEST_FLAG(stack_trace_depth)),
      skip_count + 1
      // Skips the user-specified number of frames plus this function
      // itself.
      );  // NOLINT
<span style = "background-color:#fdd">}</span>

// A helper class for measuring elapsed times.
class Timer {
 public:
<span style = "background-color:#dfd">  Timer() : start_(std::chrono::steady_clock::now()) {}</span>

  // Return time elapsed in milliseconds since the timer was created.
<span style = "background-color:#dfd">  TimeInMillis Elapsed() {
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</span>
               std::chrono::steady_clock::now() - start_)
        .count();
<span style = "background-color:#dfd">  }</span>

 private:
  std::chrono::steady_clock::time_point start_;
};

// Returns a timestamp as milliseconds since the epoch. Note this time may jump
// around subject to adjustments by the system, to measure elapsed time use
// Timer instead.
<span style = "background-color:#dfd">TimeInMillis GetTimeInMillis() {
  return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</span>
             std::chrono::system_clock::now() -
             std::chrono::system_clock::from_time_t(0))
      .count();
<span style = "background-color:#dfd">}</span>

// Utilities

// class String.

#if GTEST_OS_WINDOWS_MOBILE
// Creates a UTF-16 wide string from the given ANSI string, allocating
// memory using new. The caller is responsible for deleting the return
// value using delete[]. Returns the wide string, or NULL if the
// input is NULL.
LPCWSTR String::AnsiToUtf16(const char* ansi) {
  if (!ansi) return nullptr;
  const int length = strlen(ansi);
  const int unicode_length =
      MultiByteToWideChar(CP_ACP, 0, ansi, length, nullptr, 0);
  WCHAR* unicode = new WCHAR[unicode_length + 1];
  MultiByteToWideChar(CP_ACP, 0, ansi, length,
                      unicode, unicode_length);
  unicode[unicode_length] = 0;
  return unicode;
}

// Creates an ANSI string from the given wide string, allocating
// memory using new. The caller is responsible for deleting the return
// value using delete[]. Returns the ANSI string, or NULL if the
// input is NULL.
const char* String::Utf16ToAnsi(LPCWSTR utf16_str)  {
  if (!utf16_str) return nullptr;
  const int ansi_length = WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, nullptr,
                                              0, nullptr, nullptr);
  char* ansi = new char[ansi_length + 1];
  WideCharToMultiByte(CP_ACP, 0, utf16_str, -1, ansi, ansi_length, nullptr,
                      nullptr);
  ansi[ansi_length] = 0;
  return ansi;
}

#endif  // GTEST_OS_WINDOWS_MOBILE

// Compares two C strings.  Returns true if and only if they have the same
// content.
//
// Unlike strcmp(), this function can handle NULL argument(s).  A NULL
// C string is considered different to any non-NULL C string,
// including the empty string.
<span style = "background-color:#dfd">bool String::CStringEquals(const char * lhs, const char * rhs) {
  if (lhs == nullptr) return rhs == nullptr;</span>

<span style = "background-color:#dfd">  if (rhs == nullptr) return false;</span>

<span style = "background-color:#dfd">  return strcmp(lhs, rhs) == 0;
}</span>

#if GTEST_HAS_STD_WSTRING

// Converts an array of wide chars to a narrow string using the UTF-8
// encoding, and streams the result to the given Message object.
static void StreamWideCharsToMessage(const wchar_t* wstr, size_t length,
<span style = "background-color:#fdd">                                     Message* msg) {
  for (size_t i = 0; i != length; ) {  // NOLINT
    if (wstr[i] != L'\0') {
      *msg &lt;&lt; WideStringToUtf8(wstr + i, static_cast&lt;int&gt;(length - i));
      while (i != length &amp;&amp; wstr[i] != L'\0')
        i++;
    } else {
      *msg &lt;&lt; '\0';
      i++;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

#endif  // GTEST_HAS_STD_WSTRING

void SplitString(const ::std::string&amp; str, char delimiter,
<span style = "background-color:#fdd">                 ::std::vector&lt; ::std::string&gt;* dest) {
  ::std::vector&lt; ::std::string&gt; parsed;
  ::std::string::size_type pos = 0;
  while (::testing::internal::AlwaysTrue()) {
    const ::std::string::size_type colon = str.find(delimiter, pos);
    if (colon == ::std::string::npos) {
      parsed.push_back(str.substr(pos));
      break;
    } else {
      parsed.push_back(str.substr(pos, colon - pos));
      pos = colon + 1;</span>
    }
<span style = "background-color:#fdd">  }
  dest-&gt;swap(parsed);
}</span>

}  // namespace internal

// Constructs an empty Message.
// We allocate the stringstream separately because otherwise each use of
// ASSERT/EXPECT in a procedure adds over 200 bytes to the procedure's
// stack frame leading to huge stack frames in some cases; gcc does not reuse
// the stack space.
<span style = "background-color:#dfd">Message::Message() : ss_(new ::std::stringstream) {</span>
  // By default, we want there to be enough precision when printing
  // a double to a Message.
<span style = "background-color:#dfd">  *ss_ &lt;&lt; std::setprecision(std::numeric_limits&lt;double&gt;::digits10 + 2);
}</span>

// These two overloads allow streaming a wide C string to a Message
// using the UTF-8 encoding.
<span style = "background-color:#fdd">Message&amp; Message::operator &lt;&lt;(const wchar_t* wide_c_str) {
  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);
}
Message&amp; Message::operator &lt;&lt;(wchar_t* wide_c_str) {
  return *this &lt;&lt; internal::String::ShowWideCString(wide_c_str);
}</span>

#if GTEST_HAS_STD_WSTRING
// Converts the given wide string to a narrow string using the UTF-8
// encoding, and streams the result to this Message object.
<span style = "background-color:#fdd">Message&amp; Message::operator &lt;&lt;(const ::std::wstring&amp; wstr) {
  internal::StreamWideCharsToMessage(wstr.c_str(), wstr.length(), this);
  return *this;
}</span>
#endif  // GTEST_HAS_STD_WSTRING

// Gets the text streamed to this object so far as an std::string.
// Each '\0' character in the buffer is replaced with "\\0".
<span style = "background-color:#dfd">std::string Message::GetString() const {
  return internal::StringStreamToString(ss_.get());
}</span>

// AssertionResult constructors.
// Used in EXPECT_TRUE/FALSE(assertion_result).
AssertionResult::AssertionResult(const AssertionResult&amp; other)
<span style = "background-color:#fdd">    : success_(other.success_),
      message_(other.message_.get() != nullptr</span>
                   ? new ::std::string(*other.message_)
<span style = "background-color:#fdd">                   : static_cast&lt; ::std::string*&gt;(nullptr)) {}</span>

// Swaps two AssertionResults.
<span style = "background-color:#fdd">void AssertionResult::swap(AssertionResult&amp; other) {</span>
  using std::swap;
<span style = "background-color:#fdd">  swap(success_, other.success_);
  swap(message_, other.message_);
}</span>

// Returns the assertion's negation. Used with EXPECT/ASSERT_FALSE.
<span style = "background-color:#fdd">AssertionResult AssertionResult::operator!() const {
  AssertionResult negation(!success_);
  if (message_.get() != nullptr) negation &lt;&lt; *message_;
  return negation;
}</span>

// Makes a successful assertion result.
<span style = "background-color:#dfd">AssertionResult AssertionSuccess() {
  return AssertionResult(true);
}</span>

// Makes a failed assertion result.
<span style = "background-color:#fdd">AssertionResult AssertionFailure() {
  return AssertionResult(false);
}</span>

// Makes a failed assertion result with the given failure message.
// Deprecated; use AssertionFailure() &lt;&lt; message.
<span style = "background-color:#fdd">AssertionResult AssertionFailure(const Message&amp; message) {
  return AssertionFailure() &lt;&lt; message;
}</span>

namespace internal {

namespace edit_distance {
std::vector&lt;EditType&gt; CalculateOptimalEdits(const std::vector&lt;size_t&gt;&amp; left,
<span style = "background-color:#fdd">                                            const std::vector&lt;size_t&gt;&amp; right) {
  std::vector&lt;std::vector&lt;double&gt; &gt; costs(</span>
      left.size() + 1, std::vector&lt;double&gt;(right.size() + 1));
<span style = "background-color:#fdd">  std::vector&lt;std::vector&lt;EditType&gt; &gt; best_move(</span>
      left.size() + 1, std::vector&lt;EditType&gt;(right.size() + 1));

  // Populate for empty right.
<span style = "background-color:#fdd">  for (size_t l_i = 0; l_i &lt; costs.size(); ++l_i) {
    costs[l_i][0] = static_cast&lt;double&gt;(l_i);
    best_move[l_i][0] = kRemove;
  }</span>
  // Populate for empty left.
<span style = "background-color:#fdd">  for (size_t r_i = 1; r_i &lt; costs[0].size(); ++r_i) {
    costs[0][r_i] = static_cast&lt;double&gt;(r_i);
    best_move[0][r_i] = kAdd;
  }</span>

<span style = "background-color:#fdd">  for (size_t l_i = 0; l_i &lt; left.size(); ++l_i) {
    for (size_t r_i = 0; r_i &lt; right.size(); ++r_i) {
      if (left[l_i] == right[r_i]) {</span>
        // Found a match. Consume it.
<span style = "background-color:#fdd">        costs[l_i + 1][r_i + 1] = costs[l_i][r_i];
        best_move[l_i + 1][r_i + 1] = kMatch;
        continue;</span>
      }

<span style = "background-color:#fdd">      const double add = costs[l_i + 1][r_i];
      const double remove = costs[l_i][r_i + 1];
      const double replace = costs[l_i][r_i];
      if (add &lt; remove &amp;&amp; add &lt; replace) {
        costs[l_i + 1][r_i + 1] = add + 1;
        best_move[l_i + 1][r_i + 1] = kAdd;
      } else if (remove &lt; add &amp;&amp; remove &lt; replace) {
        costs[l_i + 1][r_i + 1] = remove + 1;
        best_move[l_i + 1][r_i + 1] = kRemove;
      } else {</span>
        // We make replace a little more expensive than add/remove to lower
        // their priority.
<span style = "background-color:#fdd">        costs[l_i + 1][r_i + 1] = replace + 1.00001;
        best_move[l_i + 1][r_i + 1] = kReplace;</span>
      }
<span style = "background-color:#fdd">    }
  }</span>

  // Reconstruct the best path. We do it in reverse order.
<span style = "background-color:#fdd">  std::vector&lt;EditType&gt; best_path;
  for (size_t l_i = left.size(), r_i = right.size(); l_i &gt; 0 || r_i &gt; 0;) {
    EditType move = best_move[l_i][r_i];
    best_path.push_back(move);
    l_i -= move != kAdd;
    r_i -= move != kRemove;
  }
  std::reverse(best_path.begin(), best_path.end());
  return best_path;
}</span>

namespace {

// Helper class to convert string into ids with deduplication.
class InternalStrings {
 public:
<span style = "background-color:#fdd">  size_t GetId(const std::string&amp; str) {
    IdMap::iterator it = ids_.find(str);
    if (it != ids_.end()) return it-&gt;second;
    size_t id = ids_.size();
    return ids_[str] = id;
  }</span>

 private:
  typedef std::map&lt;std::string, size_t&gt; IdMap;
  IdMap ids_;
};

}  // namespace

std::vector&lt;EditType&gt; CalculateOptimalEdits(
    const std::vector&lt;std::string&gt;&amp; left,
<span style = "background-color:#fdd">    const std::vector&lt;std::string&gt;&amp; right) {
  std::vector&lt;size_t&gt; left_ids, right_ids;</span>
  {
<span style = "background-color:#fdd">    InternalStrings intern_table;
    for (size_t i = 0; i &lt; left.size(); ++i) {
      left_ids.push_back(intern_table.GetId(left[i]));
    }
    for (size_t i = 0; i &lt; right.size(); ++i) {
      right_ids.push_back(intern_table.GetId(right[i]));
    }
  }
  return CalculateOptimalEdits(left_ids, right_ids);
}</span>

namespace {

// Helper class that holds the state for one hunk and prints it out to the
// stream.
// It reorders adds/removes when possible to group all removes before all
// adds. It also adds the hunk header before printint into the stream.
class Hunk {
 public:
  Hunk(size_t left_start, size_t right_start)
<span style = "background-color:#fdd">      : left_start_(left_start),
        right_start_(right_start),
        adds_(),
        removes_(),
        common_() {}</span>

<span style = "background-color:#fdd">  void PushLine(char edit, const char* line) {
    switch (edit) {</span>
      case ' ':
<span style = "background-color:#fdd">        ++common_;
        FlushEdits();
        hunk_.push_back(std::make_pair(' ', line));
        break;</span>
      case '-':
<span style = "background-color:#fdd">        ++removes_;
        hunk_removes_.push_back(std::make_pair('-', line));
        break;</span>
      case '+':
<span style = "background-color:#fdd">        ++adds_;
        hunk_adds_.push_back(std::make_pair('+', line));</span>
        break;
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  void PrintTo(std::ostream* os) {
    PrintHeader(os);
    FlushEdits();
    for (std::list&lt;std::pair&lt;char, const char*&gt; &gt;::const_iterator it =</span>
             hunk_.begin();
<span style = "background-color:#fdd">         it != hunk_.end(); ++it) {
      *os &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; "\n";
    }
  }</span>

<span style = "background-color:#fdd">  bool has_edits() const { return adds_ || removes_; }</span>

 private:
<span style = "background-color:#fdd">  void FlushEdits() {
    hunk_.splice(hunk_.end(), hunk_removes_);
    hunk_.splice(hunk_.end(), hunk_adds_);
  }</span>

  // Print a unified diff header for one hunk.
  // The format is
  //   "@@ -&lt;left_start&gt;,&lt;left_length&gt; +&lt;right_start&gt;,&lt;right_length&gt; @@"
  // where the left/right parts are omitted if unnecessary.
<span style = "background-color:#fdd">  void PrintHeader(std::ostream* ss) const {
    *ss &lt;&lt; "@@ ";
    if (removes_) {
      *ss &lt;&lt; "-" &lt;&lt; left_start_ &lt;&lt; "," &lt;&lt; (removes_ + common_);</span>
    }
<span style = "background-color:#fdd">    if (removes_ &amp;&amp; adds_) {
      *ss &lt;&lt; " ";</span>
    }
<span style = "background-color:#fdd">    if (adds_) {
      *ss &lt;&lt; "+" &lt;&lt; right_start_ &lt;&lt; "," &lt;&lt; (adds_ + common_);</span>
    }
<span style = "background-color:#fdd">    *ss &lt;&lt; " @@\n";
  }</span>

  size_t left_start_, right_start_;
  size_t adds_, removes_, common_;
  std::list&lt;std::pair&lt;char, const char*&gt; &gt; hunk_, hunk_adds_, hunk_removes_;
};

}  // namespace

// Create a list of diff hunks in Unified diff format.
// Each hunk has a header generated by PrintHeader above plus a body with
// lines prefixed with ' ' for no change, '-' for deletion and '+' for
// addition.
// 'context' represents the desired unchanged prefix/suffix around the diff.
// If two hunks are close enough that their contexts overlap, then they are
// joined into one hunk.
std::string CreateUnifiedDiff(const std::vector&lt;std::string&gt;&amp; left,
                              const std::vector&lt;std::string&gt;&amp; right,
<span style = "background-color:#fdd">                              size_t context) {
  const std::vector&lt;EditType&gt; edits = CalculateOptimalEdits(left, right);</span>

<span style = "background-color:#fdd">  size_t l_i = 0, r_i = 0, edit_i = 0;
  std::stringstream ss;
  while (edit_i &lt; edits.size()) {</span>
    // Find first edit.
<span style = "background-color:#fdd">    while (edit_i &lt; edits.size() &amp;&amp; edits[edit_i] == kMatch) {
      ++l_i;
      ++r_i;
      ++edit_i;
    }</span>

    // Find the first line to include in the hunk.
<span style = "background-color:#fdd">    const size_t prefix_context = std::min(l_i, context);
    Hunk hunk(l_i - prefix_context + 1, r_i - prefix_context + 1);
    for (size_t i = prefix_context; i &gt; 0; --i) {
      hunk.PushLine(' ', left[l_i - i].c_str());
    }</span>

    // Iterate the edits until we found enough suffix for the hunk or the input
    // is over.
<span style = "background-color:#fdd">    size_t n_suffix = 0;
    for (; edit_i &lt; edits.size(); ++edit_i) {
      if (n_suffix &gt;= context) {</span>
        // Continue only if the next hunk is very close.
<span style = "background-color:#fdd">        auto it = edits.begin() + static_cast&lt;int&gt;(edit_i);
        while (it != edits.end() &amp;&amp; *it == kMatch) ++it;
        if (it == edits.end() ||</span>
            static_cast&lt;size_t&gt;(it - edits.begin()) - edit_i &gt;= context) {
          // There is no next edit or it is too far away.
<span style = "background-color:#fdd">          break;</span>
        }
<span style = "background-color:#fdd">      }</span>

<span style = "background-color:#fdd">      EditType edit = edits[edit_i];</span>
      // Reset count when a non match is found.
<span style = "background-color:#fdd">      n_suffix = edit == kMatch ? n_suffix + 1 : 0;</span>

<span style = "background-color:#fdd">      if (edit == kMatch || edit == kRemove || edit == kReplace) {
        hunk.PushLine(edit == kMatch ? ' ' : '-', left[l_i].c_str());</span>
      }
<span style = "background-color:#fdd">      if (edit == kAdd || edit == kReplace) {
        hunk.PushLine('+', right[r_i].c_str());</span>
      }

      // Advance indices, depending on edit type.
<span style = "background-color:#fdd">      l_i += edit != kAdd;
      r_i += edit != kRemove;
    }</span>

<span style = "background-color:#fdd">    if (!hunk.has_edits()) {</span>
      // We are done. We don't want this hunk.
<span style = "background-color:#fdd">      break;</span>
    }

<span style = "background-color:#fdd">    hunk.PrintTo(&amp;ss);
  }
  return ss.str();
}</span>

}  // namespace edit_distance

namespace {

// The string representation of the values received in EqFailure() are already
// escaped. Split them on escaped '\n' boundaries. Leave all other escaped
// characters the same.
<span style = "background-color:#fdd">std::vector&lt;std::string&gt; SplitEscapedString(const std::string&amp; str) {
  std::vector&lt;std::string&gt; lines;
  size_t start = 0, end = str.size();
  if (end &gt; 2 &amp;&amp; str[0] == '"' &amp;&amp; str[end - 1] == '"') {
    ++start;
    --end;</span>
  }
<span style = "background-color:#fdd">  bool escaped = false;
  for (size_t i = start; i + 1 &lt; end; ++i) {
    if (escaped) {
      escaped = false;
      if (str[i] == 'n') {
        lines.push_back(str.substr(start, i - start - 1));
        start = i + 1;</span>
      }
<span style = "background-color:#fdd">    } else {
      escaped = str[i] == '\\';</span>
    }
<span style = "background-color:#fdd">  }
  lines.push_back(str.substr(start, end - start));
  return lines;
}</span>

}  // namespace

// Constructs and returns the message for an equality assertion
// (e.g. ASSERT_EQ, EXPECT_STREQ, etc) failure.
//
// The first four parameters are the expressions used in the assertion
// and their values, as strings.  For example, for ASSERT_EQ(foo, bar)
// where foo is 5 and bar is 6, we have:
//
//   lhs_expression: "foo"
//   rhs_expression: "bar"
//   lhs_value:      "5"
//   rhs_value:      "6"
//
// The ignoring_case parameter is true if and only if the assertion is a
// *_STRCASEEQ*.  When it's true, the string "Ignoring case" will
// be inserted into the message.
AssertionResult EqFailure(const char* lhs_expression,
                          const char* rhs_expression,
                          const std::string&amp; lhs_value,
                          const std::string&amp; rhs_value,
<span style = "background-color:#fdd">                          bool ignoring_case) {
  Message msg;
  msg &lt;&lt; "Expected equality of these values:";
  msg &lt;&lt; "\n  " &lt;&lt; lhs_expression;
  if (lhs_value != lhs_expression) {
    msg &lt;&lt; "\n    Which is: " &lt;&lt; lhs_value;</span>
  }
<span style = "background-color:#fdd">  msg &lt;&lt; "\n  " &lt;&lt; rhs_expression;
  if (rhs_value != rhs_expression) {
    msg &lt;&lt; "\n    Which is: " &lt;&lt; rhs_value;</span>
  }

<span style = "background-color:#fdd">  if (ignoring_case) {
    msg &lt;&lt; "\nIgnoring case";</span>
  }

<span style = "background-color:#fdd">  if (!lhs_value.empty() &amp;&amp; !rhs_value.empty()) {
    const std::vector&lt;std::string&gt; lhs_lines =</span>
        SplitEscapedString(lhs_value);
<span style = "background-color:#fdd">    const std::vector&lt;std::string&gt; rhs_lines =</span>
        SplitEscapedString(rhs_value);
<span style = "background-color:#fdd">    if (lhs_lines.size() &gt; 1 || rhs_lines.size() &gt; 1) {
      msg &lt;&lt; "\nWith diff:\n"</span>
          &lt;&lt; edit_distance::CreateUnifiedDiff(lhs_lines, rhs_lines);
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return AssertionFailure() &lt;&lt; msg;
}</span>

// Constructs a failure message for Boolean assertions such as EXPECT_TRUE.
std::string GetBoolAssertionFailureMessage(
    const AssertionResult&amp; assertion_result,
    const char* expression_text,
    const char* actual_predicate_value,
<span style = "background-color:#fdd">    const char* expected_predicate_value) {
  const char* actual_message = assertion_result.message();
  Message msg;
  msg &lt;&lt; "Value of: " &lt;&lt; expression_text</span>
      &lt;&lt; "\n  Actual: " &lt;&lt; actual_predicate_value;
<span style = "background-color:#fdd">  if (actual_message[0] != '\0')
    msg &lt;&lt; " (" &lt;&lt; actual_message &lt;&lt; ")";
  msg &lt;&lt; "\nExpected: " &lt;&lt; expected_predicate_value;
  return msg.GetString();
}</span>

// Helper function for implementing ASSERT_NEAR.
AssertionResult DoubleNearPredFormat(const char* expr1,
                                     const char* expr2,
                                     const char* abs_error_expr,
                                     double val1,
                                     double val2,
<span style = "background-color:#fdd">                                     double abs_error) {
  const double diff = fabs(val1 - val2);
  if (diff &lt;= abs_error) return AssertionSuccess();</span>

  // Find the value which is closest to zero.
<span style = "background-color:#fdd">  const double min_abs = std::min(fabs(val1), fabs(val2));</span>
  // Find the distance to the next double from that value.
<span style = "background-color:#fdd">  const double epsilon =</span>
      nextafter(min_abs, std::numeric_limits&lt;double&gt;::infinity()) - min_abs;
  // Detect the case where abs_error is so small that EXPECT_NEAR is
  // effectively the same as EXPECT_EQUAL, and give an informative error
  // message so that the situation can be more easily understood without
  // requiring exotic floating-point knowledge.
  // Don't do an epsilon check if abs_error is zero because that implies
  // that an equality check was actually intended.
<span style = "background-color:#fdd">  if (!(std::isnan)(val1) &amp;&amp; !(std::isnan)(val2) &amp;&amp; abs_error &gt; 0 &amp;&amp;</span>
      abs_error &lt; epsilon) {
<span style = "background-color:#fdd">    return AssertionFailure()</span>
           &lt;&lt; "The difference between " &lt;&lt; expr1 &lt;&lt; " and " &lt;&lt; expr2 &lt;&lt; " is "
           &lt;&lt; diff &lt;&lt; ", where\n"
           &lt;&lt; expr1 &lt;&lt; " evaluates to " &lt;&lt; val1 &lt;&lt; ",\n"
           &lt;&lt; expr2 &lt;&lt; " evaluates to " &lt;&lt; val2 &lt;&lt; ".\nThe abs_error parameter "
           &lt;&lt; abs_error_expr &lt;&lt; " evaluates to " &lt;&lt; abs_error
           &lt;&lt; " which is smaller than the minimum distance between doubles for "
              "numbers of this magnitude which is "
           &lt;&lt; epsilon
           &lt;&lt; ", thus making this EXPECT_NEAR check equivalent to "
              "EXPECT_EQUAL. Consider using EXPECT_DOUBLE_EQ instead.";
  }
<span style = "background-color:#fdd">  return AssertionFailure()</span>
      &lt;&lt; "The difference between " &lt;&lt; expr1 &lt;&lt; " and " &lt;&lt; expr2
      &lt;&lt; " is " &lt;&lt; diff &lt;&lt; ", which exceeds " &lt;&lt; abs_error_expr &lt;&lt; ", where\n"
      &lt;&lt; expr1 &lt;&lt; " evaluates to " &lt;&lt; val1 &lt;&lt; ",\n"
      &lt;&lt; expr2 &lt;&lt; " evaluates to " &lt;&lt; val2 &lt;&lt; ", and\n"
      &lt;&lt; abs_error_expr &lt;&lt; " evaluates to " &lt;&lt; abs_error &lt;&lt; ".";
<span style = "background-color:#fdd">}</span>


// Helper template for implementing FloatLE() and DoubleLE().
template &lt;typename RawType&gt;
AssertionResult FloatingPointLE(const char* expr1,
                                const char* expr2,
                                RawType val1,
<span style = "background-color:#fdd">                                RawType val2) {</span>
  // Returns success if val1 is less than val2,
<span style = "background-color:#fdd">  if (val1 &lt; val2) {
    return AssertionSuccess();</span>
  }

  // or if val1 is almost equal to val2.
<span style = "background-color:#fdd">  const FloatingPoint&lt;RawType&gt; lhs(val1), rhs(val2);
  if (lhs.AlmostEquals(rhs)) {
    return AssertionSuccess();</span>
  }

  // Note that the above two checks will both fail if either val1 or
  // val2 is NaN, as the IEEE floating-point standard requires that
  // any predicate involving a NaN must return false.

<span style = "background-color:#fdd">  ::std::stringstream val1_ss;
  val1_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)</span>
          &lt;&lt; val1;

<span style = "background-color:#fdd">  ::std::stringstream val2_ss;
  val2_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)</span>
          &lt;&lt; val2;

<span style = "background-color:#fdd">  return AssertionFailure()</span>
      &lt;&lt; "Expected: (" &lt;&lt; expr1 &lt;&lt; ") &lt;= (" &lt;&lt; expr2 &lt;&lt; ")\n"
      &lt;&lt; "  Actual: " &lt;&lt; StringStreamToString(&amp;val1_ss) &lt;&lt; " vs "
      &lt;&lt; StringStreamToString(&amp;val2_ss);
<span style = "background-color:#fdd">}</span>

}  // namespace internal

// Asserts that val1 is less than, or almost equal to, val2.  Fails
// otherwise.  In particular, it fails if either val1 or val2 is NaN.
AssertionResult FloatLE(const char* expr1, const char* expr2,
<span style = "background-color:#fdd">                        float val1, float val2) {
  return internal::FloatingPointLE&lt;float&gt;(expr1, expr2, val1, val2);
}</span>

// Asserts that val1 is less than, or almost equal to, val2.  Fails
// otherwise.  In particular, it fails if either val1 or val2 is NaN.
AssertionResult DoubleLE(const char* expr1, const char* expr2,
<span style = "background-color:#fdd">                         double val1, double val2) {
  return internal::FloatingPointLE&lt;double&gt;(expr1, expr2, val1, val2);
}</span>

namespace internal {

// The helper function for {ASSERT|EXPECT}_STREQ.
AssertionResult CmpHelperSTREQ(const char* lhs_expression,
                               const char* rhs_expression,
                               const char* lhs,
<span style = "background-color:#fdd">                               const char* rhs) {
  if (String::CStringEquals(lhs, rhs)) {
    return AssertionSuccess();</span>
  }

<span style = "background-color:#fdd">  return EqFailure(lhs_expression,</span>
                   rhs_expression,
                   PrintToString(lhs),
                   PrintToString(rhs),
                   false);
<span style = "background-color:#fdd">}</span>

// The helper function for {ASSERT|EXPECT}_STRCASEEQ.
AssertionResult CmpHelperSTRCASEEQ(const char* lhs_expression,
                                   const char* rhs_expression,
                                   const char* lhs,
<span style = "background-color:#fdd">                                   const char* rhs) {
  if (String::CaseInsensitiveCStringEquals(lhs, rhs)) {
    return AssertionSuccess();</span>
  }

<span style = "background-color:#fdd">  return EqFailure(lhs_expression,</span>
                   rhs_expression,
                   PrintToString(lhs),
                   PrintToString(rhs),
                   true);
<span style = "background-color:#fdd">}</span>

// The helper function for {ASSERT|EXPECT}_STRNE.
AssertionResult CmpHelperSTRNE(const char* s1_expression,
                               const char* s2_expression,
                               const char* s1,
<span style = "background-color:#fdd">                               const char* s2) {
  if (!String::CStringEquals(s1, s2)) {
    return AssertionSuccess();
  } else {
    return AssertionFailure() &lt;&lt; "Expected: (" &lt;&lt; s1_expression &lt;&lt; ") != ("</span>
                              &lt;&lt; s2_expression &lt;&lt; "), actual: \""
                              &lt;&lt; s1 &lt;&lt; "\" vs \"" &lt;&lt; s2 &lt;&lt; "\"";
  }
<span style = "background-color:#fdd">}</span>

// The helper function for {ASSERT|EXPECT}_STRCASENE.
AssertionResult CmpHelperSTRCASENE(const char* s1_expression,
                                   const char* s2_expression,
                                   const char* s1,
<span style = "background-color:#fdd">                                   const char* s2) {
  if (!String::CaseInsensitiveCStringEquals(s1, s2)) {
    return AssertionSuccess();
  } else {
    return AssertionFailure()</span>
        &lt;&lt; "Expected: (" &lt;&lt; s1_expression &lt;&lt; ") != ("
        &lt;&lt; s2_expression &lt;&lt; ") (ignoring case), actual: \""
        &lt;&lt; s1 &lt;&lt; "\" vs \"" &lt;&lt; s2 &lt;&lt; "\"";
  }
<span style = "background-color:#fdd">}</span>

}  // namespace internal

namespace {

// Helper functions for implementing IsSubString() and IsNotSubstring().

// This group of overloaded functions return true if and only if needle
// is a substring of haystack.  NULL is considered a substring of
// itself only.

<span style = "background-color:#fdd">bool IsSubstringPred(const char* needle, const char* haystack) {
  if (needle == nullptr || haystack == nullptr) return needle == haystack;</span>

<span style = "background-color:#fdd">  return strstr(haystack, needle) != nullptr;
}</span>

<span style = "background-color:#fdd">bool IsSubstringPred(const wchar_t* needle, const wchar_t* haystack) {
  if (needle == nullptr || haystack == nullptr) return needle == haystack;</span>

<span style = "background-color:#fdd">  return wcsstr(haystack, needle) != nullptr;
}</span>

// StringType here can be either ::std::string or ::std::wstring.
template &lt;typename StringType&gt;
bool IsSubstringPred(const StringType&amp; needle,
<span style = "background-color:#fdd">                     const StringType&amp; haystack) {
  return haystack.find(needle) != StringType::npos;
}</span>

// This function implements either IsSubstring() or IsNotSubstring(),
// depending on the value of the expected_to_be_substring parameter.
// StringType here can be const char*, const wchar_t*, ::std::string,
// or ::std::wstring.
template &lt;typename StringType&gt;
AssertionResult IsSubstringImpl(
    bool expected_to_be_substring,
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const StringType&amp; needle, const StringType&amp; haystack) {
  if (IsSubstringPred(needle, haystack) == expected_to_be_substring)
    return AssertionSuccess();</span>

<span style = "background-color:#fdd">  const bool is_wide_string = sizeof(needle[0]) &gt; 1;
  const char* const begin_string_quote = is_wide_string ? "L\"" : "\"";
  return AssertionFailure()</span>
      &lt;&lt; "Value of: " &lt;&lt; needle_expr &lt;&lt; "\n"
      &lt;&lt; "  Actual: " &lt;&lt; begin_string_quote &lt;&lt; needle &lt;&lt; "\"\n"
      &lt;&lt; "Expected: " &lt;&lt; (expected_to_be_substring ? "" : "not ")
      &lt;&lt; "a substring of " &lt;&lt; haystack_expr &lt;&lt; "\n"
      &lt;&lt; "Which is: " &lt;&lt; begin_string_quote &lt;&lt; haystack &lt;&lt; "\"";
<span style = "background-color:#fdd">}</span>

}  // namespace

// IsSubstring() and IsNotSubstring() check whether needle is a
// substring of haystack (NULL is considered a substring of itself
// only), and return an appropriate error message when they fail.

AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const char* needle, const char* haystack) {
  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const wchar_t* needle, const wchar_t* haystack) {
  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const char* needle, const char* haystack) {
  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const wchar_t* needle, const wchar_t* haystack) {
  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const ::std::string&amp; needle, const ::std::string&amp; haystack) {
  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const ::std::string&amp; needle, const ::std::string&amp; haystack) {
  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
}</span>

#if GTEST_HAS_STD_WSTRING
AssertionResult IsSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const ::std::wstring&amp; needle, const ::std::wstring&amp; haystack) {
  return IsSubstringImpl(true, needle_expr, haystack_expr, needle, haystack);
}</span>

AssertionResult IsNotSubstring(
    const char* needle_expr, const char* haystack_expr,
<span style = "background-color:#fdd">    const ::std::wstring&amp; needle, const ::std::wstring&amp; haystack) {
  return IsSubstringImpl(false, needle_expr, haystack_expr, needle, haystack);
}</span>
#endif  // GTEST_HAS_STD_WSTRING

namespace internal {

#if GTEST_OS_WINDOWS

namespace {

// Helper function for IsHRESULT{SuccessFailure} predicates
AssertionResult HRESULTFailureHelper(const char* expr,
                                     const char* expected,
<span style = "background-color:#fdd">                                     long hr) {  // NOLINT</span>
# if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_WINDOWS_TV_TITLE

  // Windows CE doesn't support FormatMessage.
  const char error_text[] = "";

# else

  // Looks up the human-readable system message for the HRESULT code
  // and since we're not passing any params to FormatMessage, we don't
  // want inserts expanded.
<span style = "background-color:#fdd">  const DWORD kFlags = FORMAT_MESSAGE_FROM_SYSTEM |</span>
                       FORMAT_MESSAGE_IGNORE_INSERTS;
<span style = "background-color:#fdd">  const DWORD kBufSize = 4096;</span>
  // Gets the system's human readable message string for this HRESULT.
<span style = "background-color:#fdd">  char error_text[kBufSize] = { '\0' };
  DWORD message_length = ::FormatMessageA(kFlags,</span>
                                          0,   // no source, we're asking system
                                          static_cast&lt;DWORD&gt;(hr),  // the error
                                          0,   // no line width restrictions
                                          error_text,  // output buffer
                                          kBufSize,    // buf size
                                          nullptr);  // no arguments for inserts
  // Trims tailing white space (FormatMessage leaves a trailing CR-LF)
<span style = "background-color:#fdd">  for (; message_length &amp;&amp; IsSpace(error_text[message_length - 1]);
          --message_length) {
    error_text[message_length - 1] = '\0';
  }</span>

# endif  // GTEST_OS_WINDOWS_MOBILE

<span style = "background-color:#fdd">  const std::string error_hex("0x" + String::FormatHexInt(hr));
  return ::testing::AssertionFailure()</span>
      &lt;&lt; "Expected: " &lt;&lt; expr &lt;&lt; " " &lt;&lt; expected &lt;&lt; ".\n"
      &lt;&lt; "  Actual: " &lt;&lt; error_hex &lt;&lt; " " &lt;&lt; error_text &lt;&lt; "\n";
<span style = "background-color:#fdd">}</span>

}  // namespace

<span style = "background-color:#fdd">AssertionResult IsHRESULTSuccess(const char* expr, long hr) {  // NOLINT
  if (SUCCEEDED(hr)) {
    return AssertionSuccess();</span>
  }
<span style = "background-color:#fdd">  return HRESULTFailureHelper(expr, "succeeds", hr);
}</span>

<span style = "background-color:#fdd">AssertionResult IsHRESULTFailure(const char* expr, long hr) {  // NOLINT
  if (FAILED(hr)) {
    return AssertionSuccess();</span>
  }
<span style = "background-color:#fdd">  return HRESULTFailureHelper(expr, "fails", hr);
}</span>

#endif  // GTEST_OS_WINDOWS

// Utility functions for encoding Unicode text (wide strings) in
// UTF-8.

// A Unicode code-point can have up to 21 bits, and is encoded in UTF-8
// like this:
//
// Code-point length   Encoding
//   0 -  7 bits       0xxxxxxx
//   8 - 11 bits       110xxxxx 10xxxxxx
//  12 - 16 bits       1110xxxx 10xxxxxx 10xxxxxx
//  17 - 21 bits       11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

// The maximum code-point a one-byte UTF-8 sequence can represent.
constexpr uint32_t kMaxCodePoint1 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt;  7) - 1;

// The maximum code-point a two-byte UTF-8 sequence can represent.
constexpr uint32_t kMaxCodePoint2 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (5 + 6)) - 1;

// The maximum code-point a three-byte UTF-8 sequence can represent.
constexpr uint32_t kMaxCodePoint3 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (4 + 2*6)) - 1;

// The maximum code-point a four-byte UTF-8 sequence can represent.
constexpr uint32_t kMaxCodePoint4 = (static_cast&lt;uint32_t&gt;(1) &lt;&lt; (3 + 3*6)) - 1;

// Chops off the n lowest bits from a bit pattern.  Returns the n
// lowest bits.  As a side effect, the original bit pattern will be
// shifted to the right by n bits.
<span style = "background-color:#fdd">inline uint32_t ChopLowBits(uint32_t* bits, int n) {
  const uint32_t low_bits = *bits &amp; ((static_cast&lt;uint32_t&gt;(1) &lt;&lt; n) - 1);
  *bits &gt;&gt;= n;
  return low_bits;
}</span>

// Converts a Unicode code point to a narrow string in UTF-8 encoding.
// code_point parameter is of type uint32_t because wchar_t may not be
// wide enough to contain a code point.
// If the code_point is not a valid Unicode code point
// (i.e. outside of Unicode range U+0 to U+10FFFF) it will be converted
// to "(Invalid Unicode 0xXXXXXXXX)".
<span style = "background-color:#fdd">std::string CodePointToUtf8(uint32_t code_point) {
  if (code_point &gt; kMaxCodePoint4) {
    return "(Invalid Unicode 0x" + String::FormatHexUInt32(code_point) + ")";</span>
  }

  char str[5];  // Big enough for the largest valid code point.
<span style = "background-color:#fdd">  if (code_point &lt;= kMaxCodePoint1) {
    str[1] = '\0';
    str[0] = static_cast&lt;char&gt;(code_point);                          // 0xxxxxxx
  } else if (code_point &lt;= kMaxCodePoint2) {
    str[2] = '\0';
    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[0] = static_cast&lt;char&gt;(0xC0 | code_point);                   // 110xxxxx
  } else if (code_point &lt;= kMaxCodePoint3) {
    str[3] = '\0';
    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[0] = static_cast&lt;char&gt;(0xE0 | code_point);                   // 1110xxxx
  } else {  // code_point &lt;= kMaxCodePoint4
    str[4] = '\0';
    str[3] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[2] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[1] = static_cast&lt;char&gt;(0x80 | ChopLowBits(&amp;code_point, 6));  // 10xxxxxx
    str[0] = static_cast&lt;char&gt;(0xF0 | code_point);                   // 11110xxx</span>
  }
<span style = "background-color:#fdd">  return str;
}</span>

// The following two functions only make sense if the system
// uses UTF-16 for wide string encoding. All supported systems
// with 16 bit wchar_t (Windows, Cygwin) do use UTF-16.

// Determines if the arguments constitute UTF-16 surrogate pair
// and thus should be combined into a single Unicode code point
// using CreateCodePointFromUtf16SurrogatePair.
<span style = "background-color:#fdd">inline bool IsUtf16SurrogatePair(wchar_t first, wchar_t second) {
  return sizeof(wchar_t) == 2 &amp;&amp;</span>
      (first &amp; 0xFC00) == 0xD800 &amp;&amp; (second &amp; 0xFC00) == 0xDC00;
<span style = "background-color:#fdd">}</span>

// Creates a Unicode code point from UTF16 surrogate pair.
inline uint32_t CreateCodePointFromUtf16SurrogatePair(wchar_t first,
<span style = "background-color:#fdd">                                                      wchar_t second) {
  const auto first_u = static_cast&lt;uint32_t&gt;(first);
  const auto second_u = static_cast&lt;uint32_t&gt;(second);
  const uint32_t mask = (1 &lt;&lt; 10) - 1;
  return (sizeof(wchar_t) == 2)</span>
             ? (((first_u &amp; mask) &lt;&lt; 10) | (second_u &amp; mask)) + 0x10000
             :
             // This function should not be called when the condition is
             // false, but we provide a sensible default in case it is.
             first_u;
<span style = "background-color:#fdd">}</span>

// Converts a wide string to a narrow string in UTF-8 encoding.
// The wide string is assumed to have the following encoding:
//   UTF-16 if sizeof(wchar_t) == 2 (on Windows, Cygwin)
//   UTF-32 if sizeof(wchar_t) == 4 (on Linux)
// Parameter str points to a null-terminated wide string.
// Parameter num_chars may additionally limit the number
// of wchar_t characters processed. -1 is used when the entire string
// should be processed.
// If the string contains code points that are not valid Unicode code points
// (i.e. outside of Unicode range U+0 to U+10FFFF) they will be output
// as '(Invalid Unicode 0xXXXXXXXX)'. If the string is in UTF16 encoding
// and contains invalid UTF-16 surrogate pairs, values in those pairs
// will be encoded as individual Unicode characters from Basic Normal Plane.
<span style = "background-color:#fdd">std::string WideStringToUtf8(const wchar_t* str, int num_chars) {
  if (num_chars == -1)
    num_chars = static_cast&lt;int&gt;(wcslen(str));</span>

<span style = "background-color:#fdd">  ::std::stringstream stream;
  for (int i = 0; i &lt; num_chars; ++i) {</span>
    uint32_t unicode_code_point;

<span style = "background-color:#fdd">    if (str[i] == L'\0') {
      break;
    } else if (i + 1 &lt; num_chars &amp;&amp; IsUtf16SurrogatePair(str[i], str[i + 1])) {
      unicode_code_point = CreateCodePointFromUtf16SurrogatePair(str[i],</span>
                                                                 str[i + 1]);
<span style = "background-color:#fdd">      i++;
    } else {
      unicode_code_point = static_cast&lt;uint32_t&gt;(str[i]);</span>
    }

<span style = "background-color:#fdd">    stream &lt;&lt; CodePointToUtf8(unicode_code_point);
  }
  return StringStreamToString(&amp;stream);
}</span>

// Converts a wide C string to an std::string using the UTF-8 encoding.
// NULL will be converted to "(null)".
<span style = "background-color:#fdd">std::string String::ShowWideCString(const wchar_t * wide_c_str) {
  if (wide_c_str == nullptr) return "(null)";</span>

<span style = "background-color:#fdd">  return internal::WideStringToUtf8(wide_c_str, -1);
}</span>

// Compares two wide C strings.  Returns true if and only if they have the
// same content.
//
// Unlike wcscmp(), this function can handle NULL argument(s).  A NULL
// C string is considered different to any non-NULL C string,
// including the empty string.
<span style = "background-color:#fdd">bool String::WideCStringEquals(const wchar_t * lhs, const wchar_t * rhs) {
  if (lhs == nullptr) return rhs == nullptr;</span>

<span style = "background-color:#fdd">  if (rhs == nullptr) return false;</span>

<span style = "background-color:#fdd">  return wcscmp(lhs, rhs) == 0;
}</span>

// Helper function for *_STREQ on wide strings.
AssertionResult CmpHelperSTREQ(const char* lhs_expression,
                               const char* rhs_expression,
                               const wchar_t* lhs,
<span style = "background-color:#fdd">                               const wchar_t* rhs) {
  if (String::WideCStringEquals(lhs, rhs)) {
    return AssertionSuccess();</span>
  }

<span style = "background-color:#fdd">  return EqFailure(lhs_expression,</span>
                   rhs_expression,
                   PrintToString(lhs),
                   PrintToString(rhs),
                   false);
<span style = "background-color:#fdd">}</span>

// Helper function for *_STRNE on wide strings.
AssertionResult CmpHelperSTRNE(const char* s1_expression,
                               const char* s2_expression,
                               const wchar_t* s1,
<span style = "background-color:#fdd">                               const wchar_t* s2) {
  if (!String::WideCStringEquals(s1, s2)) {
    return AssertionSuccess();</span>
  }

<span style = "background-color:#fdd">  return AssertionFailure() &lt;&lt; "Expected: (" &lt;&lt; s1_expression &lt;&lt; ") != ("</span>
                            &lt;&lt; s2_expression &lt;&lt; "), actual: "
                            &lt;&lt; PrintToString(s1)
                            &lt;&lt; " vs " &lt;&lt; PrintToString(s2);
<span style = "background-color:#fdd">}</span>

// Compares two C strings, ignoring case.  Returns true if and only if they have
// the same content.
//
// Unlike strcasecmp(), this function can handle NULL argument(s).  A
// NULL C string is considered different to any non-NULL C string,
// including the empty string.
<span style = "background-color:#dfd">bool String::CaseInsensitiveCStringEquals(const char * lhs, const char * rhs) {
  if (lhs == nullptr) return rhs == nullptr;
  if (rhs == nullptr) return false;
  return posix::StrCaseCmp(lhs, rhs) == 0;
}</span>

// Compares two wide C strings, ignoring case.  Returns true if and only if they
// have the same content.
//
// Unlike wcscasecmp(), this function can handle NULL argument(s).
// A NULL C string is considered different to any non-NULL wide C string,
// including the empty string.
// NB: The implementations on different platforms slightly differ.
// On windows, this method uses _wcsicmp which compares according to LC_CTYPE
// environment variable. On GNU platform this method uses wcscasecmp
// which compares according to LC_CTYPE category of the current locale.
// On MacOS X, it uses towlower, which also uses LC_CTYPE category of the
// current locale.
bool String::CaseInsensitiveWideCStringEquals(const wchar_t* lhs,
<span style = "background-color:#fdd">                                              const wchar_t* rhs) {
  if (lhs == nullptr) return rhs == nullptr;</span>

<span style = "background-color:#fdd">  if (rhs == nullptr) return false;</span>

#if GTEST_OS_WINDOWS
<span style = "background-color:#fdd">  return _wcsicmp(lhs, rhs) == 0;</span>
#elif GTEST_OS_LINUX &amp;&amp; !GTEST_OS_LINUX_ANDROID
  return wcscasecmp(lhs, rhs) == 0;
#else
  // Android, Mac OS X and Cygwin don't define wcscasecmp.
  // Other unknown OSes may not define it either.
  wint_t left, right;
  do {
    left = towlower(static_cast&lt;wint_t&gt;(*lhs++));
    right = towlower(static_cast&lt;wint_t&gt;(*rhs++));
  } while (left &amp;&amp; left == right);
  return left == right;
#endif  // OS selector
<span style = "background-color:#fdd">}</span>

// Returns true if and only if str ends with the given suffix, ignoring case.
// Any string is considered to end with an empty suffix.
bool String::EndsWithCaseInsensitive(
<span style = "background-color:#fdd">    const std::string&amp; str, const std::string&amp; suffix) {
  const size_t str_len = str.length();
  const size_t suffix_len = suffix.length();
  return (str_len &gt;= suffix_len) &amp;&amp;</span>
         CaseInsensitiveCStringEquals(str.c_str() + str_len - suffix_len,
                                      suffix.c_str());
<span style = "background-color:#fdd">}</span>

// Formats an int value as "%02d".
<span style = "background-color:#fdd">std::string String::FormatIntWidth2(int value) {
  return FormatIntWidthN(value, 2);
}</span>

// Formats an int value to given width with leading zeros.
<span style = "background-color:#fdd">std::string String::FormatIntWidthN(int value, int width) {
  std::stringstream ss;
  ss &lt;&lt; std::setfill('0') &lt;&lt; std::setw(width) &lt;&lt; value;
  return ss.str();
}</span>

// Formats an int value as "%X".
<span style = "background-color:#fdd">std::string String::FormatHexUInt32(uint32_t value) {
  std::stringstream ss;
  ss &lt;&lt; std::hex &lt;&lt; std::uppercase &lt;&lt; value;
  return ss.str();
}</span>

// Formats an int value as "%X".
<span style = "background-color:#fdd">std::string String::FormatHexInt(int value) {
  return FormatHexUInt32(static_cast&lt;uint32_t&gt;(value));
}</span>

// Formats a byte as "%02X".
<span style = "background-color:#fdd">std::string String::FormatByte(unsigned char value) {
  std::stringstream ss;
  ss &lt;&lt; std::setfill('0') &lt;&lt; std::setw(2) &lt;&lt; std::hex &lt;&lt; std::uppercase</span>
     &lt;&lt; static_cast&lt;unsigned int&gt;(value);
<span style = "background-color:#fdd">  return ss.str();
}</span>

// Converts the buffer in a stringstream to an std::string, converting NUL
// bytes to "\\0" along the way.
<span style = "background-color:#dfd">std::string StringStreamToString(::std::stringstream* ss) {
  const ::std::string&amp; str = ss-&gt;str();
  const char* const start = str.c_str();
  const char* const end = start + str.length();</span>

<span style = "background-color:#dfd">  std::string result;
  result.reserve(static_cast&lt;size_t&gt;(2 * (end - start)));
  for (const char* ch = start; ch != end; ++ch) {
    if (*ch == '\0') {</span>
<span style = "background-color:#fdd">      result += "\\0";  // Replaces NUL with "\\0";
    } else {</span>
<span style = "background-color:#dfd">      result += *ch;</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  return result;
}</span>

// Appends the user-supplied message to the Google-Test-generated message.
std::string AppendUserMessage(const std::string&amp; gtest_msg,
<span style = "background-color:#fdd">                              const Message&amp; user_msg) {</span>
  // Appends the user message if it's non-empty.
<span style = "background-color:#fdd">  const std::string user_msg_string = user_msg.GetString();
  if (user_msg_string.empty()) {
    return gtest_msg;</span>
  }
<span style = "background-color:#fdd">  if (gtest_msg.empty()) {
    return user_msg_string;</span>
  }
<span style = "background-color:#fdd">  return gtest_msg + "\n" + user_msg_string;
}</span>

}  // namespace internal

// class TestResult

// Creates an empty TestResult.
TestResult::TestResult()
<span style = "background-color:#dfd">    : death_test_count_(0), start_timestamp_(0), elapsed_time_(0) {}</span>

// D'tor.
<span style = "background-color:#dfd">TestResult::~TestResult() {
}</span>

// Returns the i-th test part result among all the results. i can
// range from 0 to total_part_count() - 1. If i is not in that range,
// aborts the program.
<span style = "background-color:#fdd">const TestPartResult&amp; TestResult::GetTestPartResult(int i) const {
  if (i &lt; 0 || i &gt;= total_part_count())
    internal::posix::Abort();
  return test_part_results_.at(static_cast&lt;size_t&gt;(i));
}</span>

// Returns the i-th test property. i can range from 0 to
// test_property_count() - 1. If i is not in that range, aborts the
// program.
<span style = "background-color:#fdd">const TestProperty&amp; TestResult::GetTestProperty(int i) const {
  if (i &lt; 0 || i &gt;= test_property_count())
    internal::posix::Abort();
  return test_properties_.at(static_cast&lt;size_t&gt;(i));
}</span>

// Clears the test part results.
<span style = "background-color:#fdd">void TestResult::ClearTestPartResults() {
  test_part_results_.clear();
}</span>

// Adds a test part result to the list.
<span style = "background-color:#fdd">void TestResult::AddTestPartResult(const TestPartResult&amp; test_part_result) {
  test_part_results_.push_back(test_part_result);
}</span>

// Adds a test property to the list. If a property with the same key as the
// supplied property is already represented, the value of this test_property
// replaces the old value for that key.
void TestResult::RecordProperty(const std::string&amp; xml_element,
<span style = "background-color:#fdd">                                const TestProperty&amp; test_property) {
  if (!ValidateTestProperty(xml_element, test_property)) {
    return;</span>
  }
<span style = "background-color:#fdd">  internal::MutexLock lock(&amp;test_properties_mutex_);
  const std::vector&lt;TestProperty&gt;::iterator property_with_matching_key =</span>
      std::find_if(test_properties_.begin(), test_properties_.end(),
                   internal::TestPropertyKeyIs(test_property.key()));
<span style = "background-color:#fdd">  if (property_with_matching_key == test_properties_.end()) {
    test_properties_.push_back(test_property);
    return;</span>
  }
<span style = "background-color:#fdd">  property_with_matching_key-&gt;SetValue(test_property.value());
}</span>

// The list of reserved attributes used in the &lt;testsuites&gt; element of XML
// output.
static const char* const kReservedTestSuitesAttributes[] = {
  "disabled",
  "errors",
  "failures",
  "name",
  "random_seed",
  "tests",
  "time",
  "timestamp"
};

// The list of reserved attributes used in the &lt;testsuite&gt; element of XML
// output.
static const char* const kReservedTestSuiteAttributes[] = {
    "disabled", "errors", "failures",  "name",
    "tests",    "time",   "timestamp", "skipped"};

// The list of reserved attributes used in the &lt;testcase&gt; element of XML output.
static const char* const kReservedTestCaseAttributes[] = {
    "classname",   "name", "status", "time",  "type_param",
    "value_param", "file", "line"};

// Use a slightly different set for allowed output to ensure existing tests can
// still RecordProperty("result") or "RecordProperty(timestamp")
static const char* const kReservedOutputTestCaseAttributes[] = {
    "classname",   "name", "status", "time",   "type_param",
    "value_param", "file", "line",   "result", "timestamp"};

template &lt;size_t kSize&gt;
<span style = "background-color:#fdd">std::vector&lt;std::string&gt; ArrayAsVector(const char* const (&amp;array)[kSize]) {
  return std::vector&lt;std::string&gt;(array, array + kSize);
}</span>

static std::vector&lt;std::string&gt; GetReservedAttributesForElement(
<span style = "background-color:#fdd">    const std::string&amp; xml_element) {
  if (xml_element == "testsuites") {
    return ArrayAsVector(kReservedTestSuitesAttributes);
  } else if (xml_element == "testsuite") {
    return ArrayAsVector(kReservedTestSuiteAttributes);
  } else if (xml_element == "testcase") {
    return ArrayAsVector(kReservedTestCaseAttributes);
  } else {
    GTEST_CHECK_(false) &lt;&lt; "Unrecognized xml_element provided: " &lt;&lt; xml_element;</span>
  }
  // This code is unreachable but some compilers may not realizes that.
<span style = "background-color:#fdd">  return std::vector&lt;std::string&gt;();
}</span>

// TODO(jdesprez): Merge the two getReserved attributes once skip is improved
static std::vector&lt;std::string&gt; GetReservedOutputAttributesForElement(
<span style = "background-color:#fdd">    const std::string&amp; xml_element) {
  if (xml_element == "testsuites") {
    return ArrayAsVector(kReservedTestSuitesAttributes);
  } else if (xml_element == "testsuite") {
    return ArrayAsVector(kReservedTestSuiteAttributes);
  } else if (xml_element == "testcase") {
    return ArrayAsVector(kReservedOutputTestCaseAttributes);
  } else {
    GTEST_CHECK_(false) &lt;&lt; "Unrecognized xml_element provided: " &lt;&lt; xml_element;</span>
  }
  // This code is unreachable but some compilers may not realizes that.
<span style = "background-color:#fdd">  return std::vector&lt;std::string&gt;();
}</span>

<span style = "background-color:#fdd">static std::string FormatWordList(const std::vector&lt;std::string&gt;&amp; words) {
  Message word_list;
  for (size_t i = 0; i &lt; words.size(); ++i) {
    if (i &gt; 0 &amp;&amp; words.size() &gt; 2) {
      word_list &lt;&lt; ", ";</span>
    }
<span style = "background-color:#fdd">    if (i == words.size() - 1) {
      word_list &lt;&lt; "and ";</span>
    }
<span style = "background-color:#fdd">    word_list &lt;&lt; "'" &lt;&lt; words[i] &lt;&lt; "'";
  }
  return word_list.GetString();
}</span>

static bool ValidateTestPropertyName(
    const std::string&amp; property_name,
<span style = "background-color:#fdd">    const std::vector&lt;std::string&gt;&amp; reserved_names) {
  if (std::find(reserved_names.begin(), reserved_names.end(), property_name) !=</span>
          reserved_names.end()) {
<span style = "background-color:#fdd">    ADD_FAILURE() &lt;&lt; "Reserved key used in RecordProperty(): " &lt;&lt; property_name</span>
                  &lt;&lt; " (" &lt;&lt; FormatWordList(reserved_names)
                  &lt;&lt; " are reserved by " &lt;&lt; GTEST_NAME_ &lt;&lt; ")";
<span style = "background-color:#fdd">    return false;</span>
  }
<span style = "background-color:#fdd">  return true;
}</span>

// Adds a failure if the key is a reserved attribute of the element named
// xml_element.  Returns true if the property is valid.
bool TestResult::ValidateTestProperty(const std::string&amp; xml_element,
<span style = "background-color:#fdd">                                      const TestProperty&amp; test_property) {
  return ValidateTestPropertyName(test_property.key(),</span>
                                  GetReservedAttributesForElement(xml_element));
<span style = "background-color:#fdd">}</span>

// Clears the object.
<span style = "background-color:#dfd">void TestResult::Clear() {
  test_part_results_.clear();
  test_properties_.clear();
  death_test_count_ = 0;
  elapsed_time_ = 0;
}</span>

// Returns true off the test part was skipped.
<span style = "background-color:#fdd">static bool TestPartSkipped(const TestPartResult&amp; result) {
  return result.skipped();
}</span>

// Returns true if and only if the test was skipped.
<span style = "background-color:#dfd">bool TestResult::Skipped() const {
  return !Failed() &amp;&amp; CountIf(test_part_results_, TestPartSkipped) &gt; 0;
}</span>

// Returns true if and only if the test failed.
<span style = "background-color:#dfd">bool TestResult::Failed() const {
  for (int i = 0; i &lt; total_part_count(); ++i) {</span>
<span style = "background-color:#fdd">    if (GetTestPartResult(i).failed())
      return true;
  }</span>
<span style = "background-color:#dfd">  return false;
}</span>

// Returns true if and only if the test part fatally failed.
<span style = "background-color:#fdd">static bool TestPartFatallyFailed(const TestPartResult&amp; result) {
  return result.fatally_failed();
}</span>

// Returns true if and only if the test fatally failed.
<span style = "background-color:#dfd">bool TestResult::HasFatalFailure() const {
  return CountIf(test_part_results_, TestPartFatallyFailed) &gt; 0;
}</span>

// Returns true if and only if the test part non-fatally failed.
<span style = "background-color:#fdd">static bool TestPartNonfatallyFailed(const TestPartResult&amp; result) {
  return result.nonfatally_failed();
}</span>

// Returns true if and only if the test has a non-fatal failure.
<span style = "background-color:#fdd">bool TestResult::HasNonfatalFailure() const {
  return CountIf(test_part_results_, TestPartNonfatallyFailed) &gt; 0;
}</span>

// Gets the number of all test parts.  This is the sum of the number
// of successful test parts and the number of failed test parts.
<span style = "background-color:#dfd">int TestResult::total_part_count() const {
  return static_cast&lt;int&gt;(test_part_results_.size());
}</span>

// Returns the number of the test properties.
<span style = "background-color:#fdd">int TestResult::test_property_count() const {
  return static_cast&lt;int&gt;(test_properties_.size());
}</span>

// class Test

// Creates a Test object.

// The c'tor saves the states of all flags.
Test::Test()
<span style = "background-color:#dfd">    : gtest_flag_saver_(new GTEST_FLAG_SAVER_) {
}</span>

// The d'tor restores the states of all flags.  The actual work is
// done by the d'tor of the gtest_flag_saver_ field, and thus not
// visible here.
<span style = "background-color:#dfd">Test::~Test() {
}</span>

// Sets up the test fixture.
//
// A sub-class may override this.
<span style = "background-color:#fdd">void Test::SetUp() {
}</span>

// Tears down the test fixture.
//
// A sub-class may override this.
<span style = "background-color:#dfd">void Test::TearDown() {
}</span>

// Allows user supplied key value pairs to be recorded for later output.
<span style = "background-color:#fdd">void Test::RecordProperty(const std::string&amp; key, const std::string&amp; value) {
  UnitTest::GetInstance()-&gt;RecordProperty(key, value);
}</span>

// Allows user supplied key value pairs to be recorded for later output.
<span style = "background-color:#fdd">void Test::RecordProperty(const std::string&amp; key, int value) {
  Message value_message;
  value_message &lt;&lt; value;
  RecordProperty(key, value_message.GetString().c_str());
}</span>

namespace internal {

void ReportFailureInUnknownLocation(TestPartResult::Type result_type,
<span style = "background-color:#fdd">                                    const std::string&amp; message) {</span>
  // This function is a friend of UnitTest and as such has access to
  // AddTestPartResult.
<span style = "background-color:#fdd">  UnitTest::GetInstance()-&gt;AddTestPartResult(</span>
      result_type,
      nullptr,  // No info about the source file where the exception occurred.
      -1,       // We have no info on which line caused the exception.
      message,
      "");  // No stack trace, either.
<span style = "background-color:#fdd">}</span>

}  // namespace internal

// Google Test requires all tests in the same test suite to use the same test
// fixture class.  This function checks if the current test has the
// same fixture class as the first test in the current test suite.  If
// yes, it returns true; otherwise it generates a Google Test failure and
// returns false.
<span style = "background-color:#dfd">bool Test::HasSameFixtureClass() {
  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  const TestSuite* const test_suite = impl-&gt;current_test_suite();</span>

  // Info about the first test in the current test suite.
<span style = "background-color:#dfd">  const TestInfo* const first_test_info = test_suite-&gt;test_info_list()[0];
  const internal::TypeId first_fixture_id = first_test_info-&gt;fixture_class_id_;
  const char* const first_test_name = first_test_info-&gt;name();</span>

  // Info about the current test.
<span style = "background-color:#dfd">  const TestInfo* const this_test_info = impl-&gt;current_test_info();
  const internal::TypeId this_fixture_id = this_test_info-&gt;fixture_class_id_;
  const char* const this_test_name = this_test_info-&gt;name();</span>

<span style = "background-color:#dfd">  if (this_fixture_id != first_fixture_id) {</span>
    // Is the first test defined using TEST?
<span style = "background-color:#fdd">    const bool first_is_TEST = first_fixture_id == internal::GetTestTypeId();</span>
    // Is this test defined using TEST?
<span style = "background-color:#fdd">    const bool this_is_TEST = this_fixture_id == internal::GetTestTypeId();</span>

<span style = "background-color:#fdd">    if (first_is_TEST || this_is_TEST) {</span>
      // Both TEST and TEST_F appear in same test suite, which is incorrect.
      // Tell the user how to fix this.

      // Gets the name of the TEST and the name of the TEST_F.  Note
      // that first_is_TEST and this_is_TEST cannot both be true, as
      // the fixture IDs are different for the two tests.
<span style = "background-color:#fdd">      const char* const TEST_name =</span>
          first_is_TEST ? first_test_name : this_test_name;
<span style = "background-color:#fdd">      const char* const TEST_F_name =</span>
          first_is_TEST ? this_test_name : first_test_name;

<span style = "background-color:#fdd">      ADD_FAILURE()</span>
          &lt;&lt; "All tests in the same test suite must use the same test fixture\n"
          &lt;&lt; "class, so mixing TEST_F and TEST in the same test suite is\n"
          &lt;&lt; "illegal.  In test suite " &lt;&lt; this_test_info-&gt;test_suite_name()
          &lt;&lt; ",\n"
          &lt;&lt; "test " &lt;&lt; TEST_F_name &lt;&lt; " is defined using TEST_F but\n"
          &lt;&lt; "test " &lt;&lt; TEST_name &lt;&lt; " is defined using TEST.  You probably\n"
          &lt;&lt; "want to change the TEST to TEST_F or move it to another test\n"
          &lt;&lt; "case.";
<span style = "background-color:#fdd">    } else {</span>
      // Two fixture classes with the same name appear in two different
      // namespaces, which is not allowed. Tell the user how to fix this.
<span style = "background-color:#fdd">      ADD_FAILURE()</span>
          &lt;&lt; "All tests in the same test suite must use the same test fixture\n"
          &lt;&lt; "class.  However, in test suite "
          &lt;&lt; this_test_info-&gt;test_suite_name() &lt;&lt; ",\n"
          &lt;&lt; "you defined test " &lt;&lt; first_test_name &lt;&lt; " and test "
          &lt;&lt; this_test_name &lt;&lt; "\n"
          &lt;&lt; "using two different test fixture classes.  This can happen if\n"
          &lt;&lt; "the two classes are from different namespaces or translation\n"
          &lt;&lt; "units and have the same name.  You should probably rename one\n"
          &lt;&lt; "of the classes to put the tests into different test suites.";
    }
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#dfd">  return true;
}</span>

#if GTEST_HAS_SEH

// Adds an "exception thrown" fatal failure to the current test.  This
// function returns its result via an output parameter pointer because VC++
// prohibits creation of objects with destructors on stack in functions
// using __try (see error C2712).
static std::string* FormatSehExceptionMessage(DWORD exception_code,
<span style = "background-color:#fdd">                                              const char* location) {
  Message message;
  message &lt;&lt; "SEH exception with code 0x" &lt;&lt; std::setbase(16) &lt;&lt;</span>
    exception_code &lt;&lt; std::setbase(10) &lt;&lt; " thrown in " &lt;&lt; location &lt;&lt; ".";

<span style = "background-color:#fdd">  return new std::string(message.GetString());
}</span>

#endif  // GTEST_HAS_SEH

namespace internal {

#if GTEST_HAS_EXCEPTIONS

// Adds an "exception thrown" fatal failure to the current test.
static std::string FormatCxxExceptionMessage(const char* description,
<span style = "background-color:#fdd">                                             const char* location) {
  Message message;
  if (description != nullptr) {
    message &lt;&lt; "C++ exception with description \"" &lt;&lt; description &lt;&lt; "\"";
  } else {
    message &lt;&lt; "Unknown C++ exception";</span>
  }
<span style = "background-color:#fdd">  message &lt;&lt; " thrown in " &lt;&lt; location &lt;&lt; ".";</span>

<span style = "background-color:#fdd">  return message.GetString();
}</span>

static std::string PrintTestPartResultToString(
    const TestPartResult&amp; test_part_result);

GoogleTestFailureException::GoogleTestFailureException(
    const TestPartResult&amp; failure)
<span style = "background-color:#fdd">    : ::std::runtime_error(PrintTestPartResultToString(failure).c_str()) {}</span>

#endif  // GTEST_HAS_EXCEPTIONS

// We put these helper functions in the internal namespace as IBM's xlC
// compiler rejects the code if they were declared static.

// Runs the given method and handles SEH exceptions it throws, when
// SEH is supported; returns the 0-value for type Result in case of an
// SEH exception.  (Microsoft compilers cannot handle SEH and C++
// exceptions in the same function.  Therefore, we provide a separate
// wrapper function for handling SEH exceptions.)
template &lt;class T, typename Result&gt;
Result HandleSehExceptionsInMethodIfSupported(
<span style = "background-color:#dfd">    T* object, Result (T::*method)(), const char* location) {</span>
#if GTEST_HAS_SEH
  __try {
<span style = "background-color:#dfd">    return (object-&gt;*method)();</span>
<span style = "background-color:#fdd">  } __except (internal::UnitTestOptions::GTestShouldProcessSEH(  // NOLINT</span>
      GetExceptionCode())) {
    // We create the exception message on the heap because VC++ prohibits
    // creation of objects with destructors on stack in functions using __try
    // (see error C2712).
<span style = "background-color:#fdd">    std::string* exception_message = FormatSehExceptionMessage(</span>
        GetExceptionCode(), location);
<span style = "background-color:#fdd">    internal::ReportFailureInUnknownLocation(TestPartResult::kFatalFailure,</span>
                                             *exception_message);
<span style = "background-color:#fdd">    delete exception_message;
    return static_cast&lt;Result&gt;(0);</span>
  }
#else
  (void)location;
  return (object-&gt;*method)();
#endif  // GTEST_HAS_SEH
<span style = "background-color:#dfd">}</span>

// Runs the given method and catches and reports C++ and/or SEH-style
// exceptions, if they are supported; returns the 0-value for type
// Result in case of an SEH exception.
template &lt;class T, typename Result&gt;
Result HandleExceptionsInMethodIfSupported(
<span style = "background-color:#dfd">    T* object, Result (T::*method)(), const char* location) {</span>
  // NOTE: The user code can affect the way in which Google Test handles
  // exceptions by setting GTEST_FLAG(catch_exceptions), but only before
  // RUN_ALL_TESTS() starts. It is technically possible to check the flag
  // after the exception is caught and either report or re-throw the
  // exception based on the flag's value:
  //
  // try {
  //   // Perform the test method.
  // } catch (...) {
  //   if (GTEST_FLAG(catch_exceptions))
  //     // Report the exception as failure.
  //   else
  //     throw;  // Re-throws the original exception.
  // }
  //
  // However, the purpose of this flag is to allow the program to drop into
  // the debugger when the exception is thrown. On most platforms, once the
  // control enters the catch block, the exception origin information is
  // lost and the debugger will stop the program at the point of the
  // re-throw in this function -- instead of at the point of the original
  // throw statement in the code under test.  For this reason, we perform
  // the check early, sacrificing the ability to affect Google Test's
  // exception handling in the method where the exception is thrown.
<span style = "background-color:#dfd">  if (internal::GetUnitTestImpl()-&gt;catch_exceptions()) {</span>
#if GTEST_HAS_EXCEPTIONS
    try {
<span style = "background-color:#dfd">      return HandleSehExceptionsInMethodIfSupported(object, method, location);</span>
<span style = "background-color:#fdd">    } catch (const AssertionException&amp;) {  // NOLINT</span>
      // This failure was reported already.
<span style = "background-color:#fdd">    } catch (const internal::GoogleTestFailureException&amp;) {  // NOLINT</span>
      // This exception type can only be thrown by a failed Google
      // Test assertion with the intention of letting another testing
      // framework catch it.  Therefore we just re-throw it.
<span style = "background-color:#fdd">      throw;
    } catch (const std::exception&amp; e) {  // NOLINT
      internal::ReportFailureInUnknownLocation(</span>
          TestPartResult::kFatalFailure,
          FormatCxxExceptionMessage(e.what(), location));
<span style = "background-color:#fdd">    } catch (...) {  // NOLINT
      internal::ReportFailureInUnknownLocation(</span>
          TestPartResult::kFatalFailure,
          FormatCxxExceptionMessage(nullptr, location));
<span style = "background-color:#fdd">    }
    return static_cast&lt;Result&gt;(0);</span>
#else
    return HandleSehExceptionsInMethodIfSupported(object, method, location);
#endif  // GTEST_HAS_EXCEPTIONS
<span style = "background-color:#fdd">  } else {
    return (object-&gt;*method)();</span>
  }
<span style = "background-color:#dfd">}</span>

}  // namespace internal

// Runs the test and updates the test result.
<span style = "background-color:#dfd">void Test::Run() {
  if (!HasSameFixtureClass()) return;</span>

<span style = "background-color:#dfd">  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
  internal::HandleExceptionsInMethodIfSupported(this, &amp;Test::SetUp, "SetUp()");</span>
  // We will run the test only if SetUp() was successful and didn't call
  // GTEST_SKIP().
<span style = "background-color:#dfd">  if (!HasFatalFailure() &amp;&amp; !IsSkipped()) {
    impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
    internal::HandleExceptionsInMethodIfSupported(</span>
        this, &amp;Test::TestBody, "the test body");
  }

  // However, we want to clean up as much as possible.  Hence we will
  // always call TearDown(), even if SetUp() or the test body has
  // failed.
<span style = "background-color:#dfd">  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
  internal::HandleExceptionsInMethodIfSupported(</span>
      this, &amp;Test::TearDown, "TearDown()");
<span style = "background-color:#dfd">}</span>

// Returns true if and only if the current test has a fatal failure.
<span style = "background-color:#dfd">bool Test::HasFatalFailure() {
  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;HasFatalFailure();
}</span>

// Returns true if and only if the current test has a non-fatal failure.
<span style = "background-color:#fdd">bool Test::HasNonfatalFailure() {
  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;</span>
      HasNonfatalFailure();
<span style = "background-color:#fdd">}</span>

// Returns true if and only if the current test was skipped.
<span style = "background-color:#dfd">bool Test::IsSkipped() {
  return internal::GetUnitTestImpl()-&gt;current_test_result()-&gt;Skipped();
}</span>

// class TestInfo

// Constructs a TestInfo object. It assumes ownership of the test factory
// object.
TestInfo::TestInfo(const std::string&amp; a_test_suite_name,
                   const std::string&amp; a_name, const char* a_type_param,
                   const char* a_value_param,
                   internal::CodeLocation a_code_location,
                   internal::TypeId fixture_class_id,
                   internal::TestFactoryBase* factory)
<span style = "background-color:#dfd">    : test_suite_name_(a_test_suite_name),
      name_(a_name),
      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),
      value_param_(a_value_param ? new std::string(a_value_param) : nullptr),
      location_(a_code_location),
      fixture_class_id_(fixture_class_id),
      should_run_(false),
      is_disabled_(false),
      matches_filter_(false),
      is_in_another_shard_(false),
      factory_(factory),
      result_() {}</span>

// Destructs a TestInfo object.
<span style = "background-color:#dfd">TestInfo::~TestInfo() { delete factory_; }</span>

namespace internal {

// Creates a new TestInfo object and registers it with Google Test;
// returns the created object.
//
// Arguments:
//
//   test_suite_name:  name of the test suite
//   name:             name of the test
//   type_param:       the name of the test's type parameter, or NULL if
//                     this is not a typed or a type-parameterized test.
//   value_param:      text representation of the test's value parameter,
//                     or NULL if this is not a value-parameterized test.
//   code_location:    code location where the test is defined
//   fixture_class_id: ID of the test fixture class
//   set_up_tc:        pointer to the function that sets up the test suite
//   tear_down_tc:     pointer to the function that tears down the test suite
//   factory:          pointer to the factory that creates a test object.
//                     The newly created TestInfo instance will assume
//                     ownership of the factory object.
TestInfo* MakeAndRegisterTestInfo(
    const char* test_suite_name, const char* name, const char* type_param,
    const char* value_param, CodeLocation code_location,
    TypeId fixture_class_id, SetUpTestSuiteFunc set_up_tc,
<span style = "background-color:#dfd">    TearDownTestSuiteFunc tear_down_tc, TestFactoryBase* factory) {
  TestInfo* const test_info =</span>
      new TestInfo(test_suite_name, name, type_param, value_param,
                   code_location, fixture_class_id, factory);
<span style = "background-color:#dfd">  GetUnitTestImpl()-&gt;AddTestInfo(set_up_tc, tear_down_tc, test_info);
  return test_info;
}</span>

void ReportInvalidTestSuiteType(const char* test_suite_name,
<span style = "background-color:#fdd">                                CodeLocation code_location) {
  Message errors;
  errors</span>
      &lt;&lt; "Attempted redefinition of test suite " &lt;&lt; test_suite_name &lt;&lt; ".\n"
      &lt;&lt; "All tests in the same test suite must use the same test fixture\n"
      &lt;&lt; "class.  However, in test suite " &lt;&lt; test_suite_name &lt;&lt; ", you tried\n"
      &lt;&lt; "to define a test using a fixture class different from the one\n"
      &lt;&lt; "used earlier. This can happen if the two fixture classes are\n"
      &lt;&lt; "from different namespaces and have the same name. You should\n"
      &lt;&lt; "probably rename one of the classes to put the tests into different\n"
      &lt;&lt; "test suites.";

<span style = "background-color:#fdd">  GTEST_LOG_(ERROR) &lt;&lt; FormatFileLocation(code_location.file.c_str(),</span>
                                          code_location.line)
                    &lt;&lt; " " &lt;&lt; errors.GetString();
<span style = "background-color:#fdd">}</span>
}  // namespace internal

namespace {

// A predicate that checks the test name of a TestInfo against a known
// value.
//
// This is used for implementation of the TestSuite class only.  We put
// it in the anonymous namespace to prevent polluting the outer
// namespace.
//
// TestNameIs is copyable.
class TestNameIs {
 public:
  // Constructor.
  //
  // TestNameIs has NO default constructor.
  explicit TestNameIs(const char* name)
      : name_(name) {}

  // Returns true if and only if the test name of test_info matches name_.
  bool operator()(const TestInfo * test_info) const {
    return test_info &amp;&amp; test_info-&gt;name() == name_;
  }

 private:
  std::string name_;
};

}  // namespace

namespace internal {

// This method expands all parameterized tests registered with macros TEST_P
// and INSTANTIATE_TEST_SUITE_P into regular tests and registers those.
// This will be done just once during the program runtime.
<span style = "background-color:#dfd">void UnitTestImpl::RegisterParameterizedTests() {
  if (!parameterized_tests_registered_) {
    parameterized_test_registry_.RegisterTests();
    type_parameterized_test_registry_.CheckForInstantiations();
    parameterized_tests_registered_ = true;</span>
  }
<span style = "background-color:#dfd">}</span>

}  // namespace internal

// Creates the test object, runs it, records its result, and then
// deletes it.
<span style = "background-color:#dfd">void TestInfo::Run() {
  if (!should_run_) return;</span>

  // Tells UnitTest where to store test result.
<span style = "background-color:#dfd">  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  impl-&gt;set_current_test_info(this);</span>

<span style = "background-color:#dfd">  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();</span>

  // Notifies the unit test event listeners that a test is about to start.
<span style = "background-color:#dfd">  repeater-&gt;OnTestStart(*this);</span>

<span style = "background-color:#dfd">  result_.set_start_timestamp(internal::GetTimeInMillis());
  internal::Timer timer;</span>

<span style = "background-color:#dfd">  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();</span>

  // Creates the test object.
<span style = "background-color:#dfd">  Test* const test = internal::HandleExceptionsInMethodIfSupported(</span>
      factory_, &amp;internal::TestFactoryBase::CreateTest,
      "the test fixture's constructor");

  // Runs the test if the constructor didn't generate a fatal failure or invoke
  // GTEST_SKIP().
  // Note that the object will not be null
<span style = "background-color:#dfd">  if (!Test::HasFatalFailure() &amp;&amp; !Test::IsSkipped()) {</span>
    // This doesn't throw as all user code that can throw are wrapped into
    // exception handling code.
<span style = "background-color:#dfd">    test-&gt;Run();</span>
  }

<span style = "background-color:#dfd">  if (test != nullptr) {</span>
    // Deletes the test object.
<span style = "background-color:#dfd">    impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
    internal::HandleExceptionsInMethodIfSupported(</span>
        test, &amp;Test::DeleteSelf_, "the test fixture's destructor");
  }

<span style = "background-color:#dfd">  result_.set_elapsed_time(timer.Elapsed());</span>

  // Notifies the unit test event listener that a test has just finished.
<span style = "background-color:#dfd">  repeater-&gt;OnTestEnd(*this);</span>

  // Tells UnitTest to stop associating assertion results to this
  // test.
<span style = "background-color:#dfd">  impl-&gt;set_current_test_info(nullptr);
}</span>

// Skip and records a skipped test result for this object.
<span style = "background-color:#fdd">void TestInfo::Skip() {
  if (!should_run_) return;</span>

<span style = "background-color:#fdd">  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  impl-&gt;set_current_test_info(this);</span>

<span style = "background-color:#fdd">  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();</span>

  // Notifies the unit test event listeners that a test is about to start.
<span style = "background-color:#fdd">  repeater-&gt;OnTestStart(*this);</span>

<span style = "background-color:#fdd">  const TestPartResult test_part_result =</span>
      TestPartResult(TestPartResult::kSkip, this-&gt;file(), this-&gt;line(), "");
<span style = "background-color:#fdd">  impl-&gt;GetTestPartResultReporterForCurrentThread()-&gt;ReportTestPartResult(</span>
      test_part_result);

  // Notifies the unit test event listener that a test has just finished.
<span style = "background-color:#fdd">  repeater-&gt;OnTestEnd(*this);
  impl-&gt;set_current_test_info(nullptr);
}</span>

// class TestSuite

// Gets the number of successful tests in this test suite.
<span style = "background-color:#dfd">int TestSuite::successful_test_count() const {
  return CountIf(test_info_list_, TestPassed);
}</span>

// Gets the number of successful tests in this test suite.
<span style = "background-color:#dfd">int TestSuite::skipped_test_count() const {
  return CountIf(test_info_list_, TestSkipped);
}</span>

// Gets the number of failed tests in this test suite.
<span style = "background-color:#dfd">int TestSuite::failed_test_count() const {
  return CountIf(test_info_list_, TestFailed);
}</span>

// Gets the number of disabled tests that will be reported in the XML report.
<span style = "background-color:#dfd">int TestSuite::reportable_disabled_test_count() const {
  return CountIf(test_info_list_, TestReportableDisabled);
}</span>

// Gets the number of disabled tests in this test suite.
<span style = "background-color:#fdd">int TestSuite::disabled_test_count() const {
  return CountIf(test_info_list_, TestDisabled);
}</span>

// Gets the number of tests to be printed in the XML report.
<span style = "background-color:#fdd">int TestSuite::reportable_test_count() const {
  return CountIf(test_info_list_, TestReportable);
}</span>

// Get the number of tests in this test suite that should run.
<span style = "background-color:#dfd">int TestSuite::test_to_run_count() const {
  return CountIf(test_info_list_, ShouldRunTest);
}</span>

// Gets the number of all tests.
<span style = "background-color:#dfd">int TestSuite::total_test_count() const {
  return static_cast&lt;int&gt;(test_info_list_.size());
}</span>

// Creates a TestSuite with the given name.
//
// Arguments:
//
//   a_name:       name of the test suite
//   a_type_param: the name of the test suite's type parameter, or NULL if
//                 this is not a typed or a type-parameterized test suite.
//   set_up_tc:    pointer to the function that sets up the test suite
//   tear_down_tc: pointer to the function that tears down the test suite
TestSuite::TestSuite(const char* a_name, const char* a_type_param,
                     internal::SetUpTestSuiteFunc set_up_tc,
                     internal::TearDownTestSuiteFunc tear_down_tc)
<span style = "background-color:#dfd">    : name_(a_name),
      type_param_(a_type_param ? new std::string(a_type_param) : nullptr),
      set_up_tc_(set_up_tc),
      tear_down_tc_(tear_down_tc),
      should_run_(false),
      start_timestamp_(0),
      elapsed_time_(0) {}</span>

// Destructor of TestSuite.
<span style = "background-color:#dfd">TestSuite::~TestSuite() {</span>
  // Deletes every Test in the collection.
<span style = "background-color:#dfd">  ForEach(test_info_list_, internal::Delete&lt;TestInfo&gt;);
}</span>

// Returns the i-th test among all the tests. i can range from 0 to
// total_test_count() - 1. If i is not in that range, returns NULL.
<span style = "background-color:#fdd">const TestInfo* TestSuite::GetTestInfo(int i) const {
  const int index = GetElementOr(test_indices_, i, -1);
  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];
}</span>

// Returns the i-th test among all the tests. i can range from 0 to
// total_test_count() - 1. If i is not in that range, returns NULL.
<span style = "background-color:#dfd">TestInfo* TestSuite::GetMutableTestInfo(int i) {
  const int index = GetElementOr(test_indices_, i, -1);
  return index &lt; 0 ? nullptr : test_info_list_[static_cast&lt;size_t&gt;(index)];
}</span>

// Adds a test to this test suite.  Will delete the test upon
// destruction of the TestSuite object.
<span style = "background-color:#dfd">void TestSuite::AddTestInfo(TestInfo* test_info) {
  test_info_list_.push_back(test_info);
  test_indices_.push_back(static_cast&lt;int&gt;(test_indices_.size()));
}</span>

// Runs every test in this TestSuite.
<span style = "background-color:#dfd">void TestSuite::Run() {
  if (!should_run_) return;</span>

<span style = "background-color:#dfd">  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  impl-&gt;set_current_test_suite(this);</span>

<span style = "background-color:#dfd">  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();</span>

  // Call both legacy and the new API
<span style = "background-color:#dfd">  repeater-&gt;OnTestSuiteStart(*this);</span>
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">  repeater-&gt;OnTestCaseStart(*this);</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#dfd">  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
  internal::HandleExceptionsInMethodIfSupported(</span>
      this, &amp;TestSuite::RunSetUpTestSuite, "SetUpTestSuite()");

<span style = "background-color:#dfd">  start_timestamp_ = internal::GetTimeInMillis();
  internal::Timer timer;
  for (int i = 0; i &lt; total_test_count(); i++) {
    GetMutableTestInfo(i)-&gt;Run();
    if (GTEST_FLAG(fail_fast) &amp;&amp; GetMutableTestInfo(i)-&gt;result()-&gt;Failed()) {</span>
<span style = "background-color:#fdd">      for (int j = i + 1; j &lt; total_test_count(); j++) {
        GetMutableTestInfo(j)-&gt;Skip();
      }
      break;</span>
    }
<span style = "background-color:#dfd">  }
  elapsed_time_ = timer.Elapsed();</span>

<span style = "background-color:#dfd">  impl-&gt;os_stack_trace_getter()-&gt;UponLeavingGTest();
  internal::HandleExceptionsInMethodIfSupported(</span>
      this, &amp;TestSuite::RunTearDownTestSuite, "TearDownTestSuite()");

  // Call both legacy and the new API
<span style = "background-color:#dfd">  repeater-&gt;OnTestSuiteEnd(*this);</span>
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">  repeater-&gt;OnTestCaseEnd(*this);</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#dfd">  impl-&gt;set_current_test_suite(nullptr);
}</span>

// Skips all tests under this TestSuite.
<span style = "background-color:#fdd">void TestSuite::Skip() {
  if (!should_run_) return;</span>

<span style = "background-color:#fdd">  internal::UnitTestImpl* const impl = internal::GetUnitTestImpl();
  impl-&gt;set_current_test_suite(this);</span>

<span style = "background-color:#fdd">  TestEventListener* repeater = UnitTest::GetInstance()-&gt;listeners().repeater();</span>

  // Call both legacy and the new API
<span style = "background-color:#fdd">  repeater-&gt;OnTestSuiteStart(*this);</span>
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">  repeater-&gt;OnTestCaseStart(*this);</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#fdd">  for (int i = 0; i &lt; total_test_count(); i++) {
    GetMutableTestInfo(i)-&gt;Skip();
  }</span>

  // Call both legacy and the new API
<span style = "background-color:#fdd">  repeater-&gt;OnTestSuiteEnd(*this);</span>
  // Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">  repeater-&gt;OnTestCaseEnd(*this);</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#fdd">  impl-&gt;set_current_test_suite(nullptr);
}</span>

// Clears the results of all tests in this test suite.
<span style = "background-color:#dfd">void TestSuite::ClearResult() {
  ad_hoc_test_result_.Clear();
  ForEach(test_info_list_, TestInfo::ClearTestResult);
}</span>

// Shuffles the tests in this test suite.
<span style = "background-color:#fdd">void TestSuite::ShuffleTests(internal::Random* random) {
  Shuffle(random, &amp;test_indices_);
}</span>

// Restores the test order to before the first shuffle.
<span style = "background-color:#dfd">void TestSuite::UnshuffleTests() {
  for (size_t i = 0; i &lt; test_indices_.size(); i++) {
    test_indices_[i] = static_cast&lt;int&gt;(i);
  }
}</span>

// Formats a countable noun.  Depending on its quantity, either the
// singular form or the plural form is used. e.g.
//
// FormatCountableNoun(1, "formula", "formuli") returns "1 formula".
// FormatCountableNoun(5, "book", "books") returns "5 books".
static std::string FormatCountableNoun(int count,
                                       const char * singular_form,
<span style = "background-color:#dfd">                                       const char * plural_form) {
  return internal::StreamableToString(count) + " " +</span>
      (count == 1 ? singular_form : plural_form);
<span style = "background-color:#dfd">}</span>

// Formats the count of tests.
<span style = "background-color:#dfd">static std::string FormatTestCount(int test_count) {
  return FormatCountableNoun(test_count, "test", "tests");
}</span>

// Formats the count of test suites.
<span style = "background-color:#dfd">static std::string FormatTestSuiteCount(int test_suite_count) {
  return FormatCountableNoun(test_suite_count, "test suite", "test suites");
}</span>

// Converts a TestPartResult::Type enum to human-friendly string
// representation.  Both kNonFatalFailure and kFatalFailure are translated
// to "Failure", as the user usually doesn't care about the difference
// between the two when viewing the test result.
<span style = "background-color:#fdd">static const char * TestPartResultTypeToString(TestPartResult::Type type) {
  switch (type) {</span>
    case TestPartResult::kSkip:
<span style = "background-color:#fdd">      return "Skipped\n";</span>
    case TestPartResult::kSuccess:
<span style = "background-color:#fdd">      return "Success";</span>

    case TestPartResult::kNonFatalFailure:
    case TestPartResult::kFatalFailure:
#ifdef _MSC_VER
<span style = "background-color:#fdd">      return "error: ";</span>
#else
      return "Failure\n";
#endif
    default:
<span style = "background-color:#fdd">      return "Unknown result type";</span>
  }
<span style = "background-color:#fdd">}</span>

namespace internal {
namespace {
enum class GTestColor { kDefault, kRed, kGreen, kYellow };
}  // namespace

// Prints a TestPartResult to an std::string.
static std::string PrintTestPartResultToString(
<span style = "background-color:#fdd">    const TestPartResult&amp; test_part_result) {
  return (Message()</span>
          &lt;&lt; internal::FormatFileLocation(test_part_result.file_name(),
                                          test_part_result.line_number())
          &lt;&lt; " " &lt;&lt; TestPartResultTypeToString(test_part_result.type())
          &lt;&lt; test_part_result.message()).GetString();
<span style = "background-color:#fdd">}</span>

// Prints a TestPartResult.
<span style = "background-color:#fdd">static void PrintTestPartResult(const TestPartResult&amp; test_part_result) {
  const std::string&amp; result =</span>
      PrintTestPartResultToString(test_part_result);
<span style = "background-color:#fdd">  printf("%s\n", result.c_str());
  fflush(stdout);</span>
  // If the test program runs in Visual Studio or a debugger, the
  // following statements add the test part result message to the Output
  // window such that the user can double-click on it to jump to the
  // corresponding source code location; otherwise they do nothing.
#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE
  // We don't call OutputDebugString*() on Windows Mobile, as printing
  // to stdout is done by OutputDebugString() there already - we don't
  // want the same message printed twice.
<span style = "background-color:#fdd">  ::OutputDebugStringA(result.c_str());
  ::OutputDebugStringA("\n");</span>
#endif
<span style = "background-color:#fdd">}</span>

// class PrettyUnitTestResultPrinter
#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE &amp;&amp; \
    !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT &amp;&amp; !GTEST_OS_WINDOWS_MINGW

// Returns the character attribute for the given color.
<span style = "background-color:#dfd">static WORD GetColorAttribute(GTestColor color) {
  switch (color) {</span>
    case GTestColor::kRed:
<span style = "background-color:#fdd">      return FOREGROUND_RED;</span>
    case GTestColor::kGreen:
<span style = "background-color:#dfd">      return FOREGROUND_GREEN;</span>
    case GTestColor::kYellow:
<span style = "background-color:#fdd">      return FOREGROUND_RED | FOREGROUND_GREEN;
    default:           return 0;</span>
  }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">static int GetBitOffset(WORD color_mask) {
  if (color_mask == 0) return 0;</span>

<span style = "background-color:#dfd">  int bitOffset = 0;
  while ((color_mask &amp; 1) == 0) {
    color_mask &gt;&gt;= 1;
    ++bitOffset;
  }
  return bitOffset;
}</span>

<span style = "background-color:#dfd">static WORD GetNewColor(GTestColor color, WORD old_color_attrs) {</span>
  // Let's reuse the BG
  static const WORD background_mask = BACKGROUND_BLUE | BACKGROUND_GREEN |
                                      BACKGROUND_RED | BACKGROUND_INTENSITY;
  static const WORD foreground_mask = FOREGROUND_BLUE | FOREGROUND_GREEN |
                                      FOREGROUND_RED | FOREGROUND_INTENSITY;
<span style = "background-color:#dfd">  const WORD existing_bg = old_color_attrs &amp; background_mask;</span>

<span style = "background-color:#dfd">  WORD new_color =</span>
      GetColorAttribute(color) | existing_bg | FOREGROUND_INTENSITY;
<span style = "background-color:#dfd">  static const int bg_bitOffset = GetBitOffset(background_mask);
  static const int fg_bitOffset = GetBitOffset(foreground_mask);</span>

<span style = "background-color:#dfd">  if (((new_color &amp; background_mask) &gt;&gt; bg_bitOffset) ==</span>
      ((new_color &amp; foreground_mask) &gt;&gt; fg_bitOffset)) {
<span style = "background-color:#fdd">    new_color ^= FOREGROUND_INTENSITY;  // invert intensity</span>
  }
<span style = "background-color:#dfd">  return new_color;
}</span>

#else

// Returns the ANSI color code for the given color. GTestColor::kDefault is
// an invalid input.
static const char* GetAnsiColorCode(GTestColor color) {
  switch (color) {
    case GTestColor::kRed:
      return "1";
    case GTestColor::kGreen:
      return "2";
    case GTestColor::kYellow:
      return "3";
    default:
      return nullptr;
  }
}

#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE

// Returns true if and only if Google Test should use colors in the output.
<span style = "background-color:#dfd">bool ShouldUseColor(bool stdout_is_tty) {
  const char* const gtest_color = GTEST_FLAG(color).c_str();</span>

<span style = "background-color:#dfd">  if (String::CaseInsensitiveCStringEquals(gtest_color, "auto")) {</span>
#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MINGW
    // On Windows the TERM variable is usually not set, but the
    // console there does support colors.
<span style = "background-color:#dfd">    return stdout_is_tty;</span>
#else
    // On non-Windows platforms, we rely on the TERM variable.
    const char* const term = posix::GetEnv("TERM");
    const bool term_supports_color =
        String::CStringEquals(term, "xterm") ||
        String::CStringEquals(term, "xterm-color") ||
        String::CStringEquals(term, "xterm-256color") ||
        String::CStringEquals(term, "screen") ||
        String::CStringEquals(term, "screen-256color") ||
        String::CStringEquals(term, "tmux") ||
        String::CStringEquals(term, "tmux-256color") ||
        String::CStringEquals(term, "rxvt-unicode") ||
        String::CStringEquals(term, "rxvt-unicode-256color") ||
        String::CStringEquals(term, "linux") ||
        String::CStringEquals(term, "cygwin");
    return stdout_is_tty &amp;&amp; term_supports_color;
#endif  // GTEST_OS_WINDOWS
  }

<span style = "background-color:#fdd">  return String::CaseInsensitiveCStringEquals(gtest_color, "yes") ||</span>
      String::CaseInsensitiveCStringEquals(gtest_color, "true") ||
      String::CaseInsensitiveCStringEquals(gtest_color, "t") ||
      String::CStringEquals(gtest_color, "1");
  // We take "yes", "true", "t", and "1" as meaning "yes".  If the
  // value is neither one of these nor "auto", we treat it as "no" to
  // be conservative.
<span style = "background-color:#dfd">}</span>

// Helpers for printing colored strings to stdout. Note that on Windows, we
// cannot simply emit special characters and have the terminal change colors.
// This routine must actually emit the characters rather than return a string
// that would be colored when printed, as can be done on Linux.

GTEST_ATTRIBUTE_PRINTF_(2, 3)
<span style = "background-color:#dfd">static void ColoredPrintf(GTestColor color, const char *fmt, ...) {</span>
  va_list args;
<span style = "background-color:#dfd">  va_start(args, fmt);</span>

#if GTEST_OS_WINDOWS_MOBILE || GTEST_OS_ZOS || GTEST_OS_IOS || \
    GTEST_OS_WINDOWS_PHONE || GTEST_OS_WINDOWS_RT || defined(ESP_PLATFORM)
  const bool use_color = AlwaysFalse();
#else
<span style = "background-color:#dfd">  static const bool in_color_mode =</span>
      ShouldUseColor(posix::IsATTY(posix::FileNo(stdout)) != 0);
<span style = "background-color:#dfd">  const bool use_color = in_color_mode &amp;&amp; (color != GTestColor::kDefault);</span>
#endif  // GTEST_OS_WINDOWS_MOBILE || GTEST_OS_ZOS

<span style = "background-color:#dfd">  if (!use_color) {</span>
<span style = "background-color:#fdd">    vprintf(fmt, args);
    va_end(args);
    return;</span>
  }

#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE &amp;&amp; \
    !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT &amp;&amp; !GTEST_OS_WINDOWS_MINGW
<span style = "background-color:#dfd">  const HANDLE stdout_handle = GetStdHandle(STD_OUTPUT_HANDLE);</span>

  // Gets the current text color.
  CONSOLE_SCREEN_BUFFER_INFO buffer_info;
<span style = "background-color:#dfd">  GetConsoleScreenBufferInfo(stdout_handle, &amp;buffer_info);
  const WORD old_color_attrs = buffer_info.wAttributes;
  const WORD new_color = GetNewColor(color, old_color_attrs);</span>

  // We need to flush the stream buffers into the console before each
  // SetConsoleTextAttribute call lest it affect the text that is already
  // printed but has not yet reached the console.
<span style = "background-color:#dfd">  fflush(stdout);
  SetConsoleTextAttribute(stdout_handle, new_color);</span>

<span style = "background-color:#dfd">  vprintf(fmt, args);</span>

<span style = "background-color:#dfd">  fflush(stdout);</span>
  // Restores the text color.
<span style = "background-color:#dfd">  SetConsoleTextAttribute(stdout_handle, old_color_attrs);</span>
#else
  printf("\033[0;3%sm", GetAnsiColorCode(color));
  vprintf(fmt, args);
  printf("\033[m");  // Resets the terminal to default.
#endif  // GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_MOBILE
<span style = "background-color:#dfd">  va_end(args);
}</span>

// Text printed in Google Test's text output and --gtest_list_tests
// output to label the type parameter and value parameter for a test.
static const char kTypeParamLabel[] = "TypeParam";
static const char kValueParamLabel[] = "GetParam()";

<span style = "background-color:#fdd">static void PrintFullTestCommentIfPresent(const TestInfo&amp; test_info) {
  const char* const type_param = test_info.type_param();
  const char* const value_param = test_info.value_param();</span>

<span style = "background-color:#fdd">  if (type_param != nullptr || value_param != nullptr) {
    printf(", where ");
    if (type_param != nullptr) {
      printf("%s = %s", kTypeParamLabel, type_param);
      if (value_param != nullptr) printf(" and ");</span>
    }
<span style = "background-color:#fdd">    if (value_param != nullptr) {
      printf("%s = %s", kValueParamLabel, value_param);</span>
    }
  }
<span style = "background-color:#fdd">}</span>

// This class implements the TestEventListener interface.
//
// Class PrettyUnitTestResultPrinter is copyable.
class PrettyUnitTestResultPrinter : public TestEventListener {
 public:
<span style = "background-color:#dfd">  PrettyUnitTestResultPrinter() {}
  static void PrintTestName(const char* test_suite, const char* test) {
    printf("%s.%s", test_suite, test);
  }</span>

  // The following methods override what's in the TestEventListener class.
<span style = "background-color:#dfd">  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}</span>
  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;
  void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) override;
<span style = "background-color:#dfd">  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}</span>
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestCaseStart(const TestCase&amp; test_case) override;
#else
  void OnTestSuiteStart(const TestSuite&amp; test_suite) override;
#endif  // OnTestCaseStart

  void OnTestStart(const TestInfo&amp; test_info) override;

  void OnTestPartResult(const TestPartResult&amp; result) override;
  void OnTestEnd(const TestInfo&amp; test_info) override;
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestCaseEnd(const TestCase&amp; test_case) override;
#else
  void OnTestSuiteEnd(const TestSuite&amp; test_suite) override;
#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_

  void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) override;
<span style = "background-color:#dfd">  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}</span>
  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;
<span style = "background-color:#dfd">  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}</span>

 private:
  static void PrintFailedTests(const UnitTest&amp; unit_test);
  static void PrintFailedTestSuites(const UnitTest&amp; unit_test);
  static void PrintSkippedTests(const UnitTest&amp; unit_test);
};

  // Fired before each iteration of tests starts.
void PrettyUnitTestResultPrinter::OnTestIterationStart(
<span style = "background-color:#dfd">    const UnitTest&amp; unit_test, int iteration) {
  if (GTEST_FLAG(repeat) != 1)</span>
<span style = "background-color:#fdd">    printf("\nRepeating all tests (iteration %d) . . .\n\n", iteration + 1);</span>

<span style = "background-color:#dfd">  const char* const filter = GTEST_FLAG(filter).c_str();</span>

  // Prints the filter if it's not *.  This reminds the user that some
  // tests may be skipped.
<span style = "background-color:#dfd">  if (!String::CStringEquals(filter, kUniversalFilter)) {</span>
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kYellow, "Note: %s filter = %s\n", GTEST_NAME_,</span>
                  filter);
  }

<span style = "background-color:#dfd">  if (internal::ShouldShard(kTestTotalShards, kTestShardIndex, false)) {</span>
<span style = "background-color:#fdd">    const int32_t shard_index = Int32FromEnvOrDie(kTestShardIndex, -1);
    ColoredPrintf(GTestColor::kYellow, "Note: This is test shard %d of %s.\n",</span>
                  static_cast&lt;int&gt;(shard_index) + 1,
                  internal::posix::GetEnv(kTestTotalShards));
  }

<span style = "background-color:#dfd">  if (GTEST_FLAG(shuffle)) {</span>
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kYellow,</span>
                  "Note: Randomizing tests' orders with a seed of %d .\n",
                  unit_test.random_seed());
  }

<span style = "background-color:#dfd">  ColoredPrintf(GTestColor::kGreen, "[==========] ");
  printf("Running %s from %s.\n",</span>
         FormatTestCount(unit_test.test_to_run_count()).c_str(),
         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
<span style = "background-color:#dfd">  fflush(stdout);
}</span>

void PrettyUnitTestResultPrinter::OnEnvironmentsSetUpStart(
<span style = "background-color:#dfd">    const UnitTest&amp; /*unit_test*/) {
  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("Global test environment set-up.\n");
  fflush(stdout);
}</span>

#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">void PrettyUnitTestResultPrinter::OnTestCaseStart(const TestCase&amp; test_case) {
  const std::string counts =</span>
      FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
<span style = "background-color:#dfd">  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("%s from %s", counts.c_str(), test_case.name());
  if (test_case.type_param() == nullptr) {
    printf("\n");
  } else {</span>
<span style = "background-color:#fdd">    printf(", where %s = %s\n", kTypeParamLabel, test_case.type_param());</span>
  }
<span style = "background-color:#dfd">  fflush(stdout);
}</span>
#else
void PrettyUnitTestResultPrinter::OnTestSuiteStart(
    const TestSuite&amp; test_suite) {
  const std::string counts =
      FormatCountableNoun(test_suite.test_to_run_count(), "test", "tests");
  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("%s from %s", counts.c_str(), test_suite.name());
  if (test_suite.type_param() == nullptr) {
    printf("\n");
  } else {
    printf(", where %s = %s\n", kTypeParamLabel, test_suite.type_param());
  }
  fflush(stdout);
}
#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#dfd">void PrettyUnitTestResultPrinter::OnTestStart(const TestInfo&amp; test_info) {
  ColoredPrintf(GTestColor::kGreen, "[ RUN      ] ");
  PrintTestName(test_info.test_suite_name(), test_info.name());
  printf("\n");
  fflush(stdout);
}</span>

// Called after an assertion failure.
void PrettyUnitTestResultPrinter::OnTestPartResult(
<span style = "background-color:#fdd">    const TestPartResult&amp; result) {
  switch (result.type()) {</span>
    // If the test part succeeded, we don't need to do anything.
    case TestPartResult::kSuccess:
<span style = "background-color:#fdd">      return;</span>
    default:
      // Print failure message from the assertion
      // (e.g. expected this and got that).
<span style = "background-color:#fdd">      PrintTestPartResult(result);
      fflush(stdout);</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#dfd">void PrettyUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {
  if (test_info.result()-&gt;Passed()) {
    ColoredPrintf(GTestColor::kGreen, "[       OK ] ");</span>
<span style = "background-color:#fdd">  } else if (test_info.result()-&gt;Skipped()) {
    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
  } else {
    ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");</span>
  }
<span style = "background-color:#dfd">  PrintTestName(test_info.test_suite_name(), test_info.name());
  if (test_info.result()-&gt;Failed())</span>
<span style = "background-color:#fdd">    PrintFullTestCommentIfPresent(test_info);</span>

<span style = "background-color:#dfd">  if (GTEST_FLAG(print_time)) {
    printf(" (%s ms)\n", internal::StreamableToString(</span>
           test_info.result()-&gt;elapsed_time()).c_str());
<span style = "background-color:#dfd">  } else {</span>
<span style = "background-color:#fdd">    printf("\n");</span>
  }
<span style = "background-color:#dfd">  fflush(stdout);
}</span>

#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">void PrettyUnitTestResultPrinter::OnTestCaseEnd(const TestCase&amp; test_case) {
  if (!GTEST_FLAG(print_time)) return;</span>

<span style = "background-color:#dfd">  const std::string counts =</span>
      FormatCountableNoun(test_case.test_to_run_count(), "test", "tests");
<span style = "background-color:#dfd">  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("%s from %s (%s ms total)\n\n", counts.c_str(), test_case.name(),</span>
         internal::StreamableToString(test_case.elapsed_time()).c_str());
<span style = "background-color:#dfd">  fflush(stdout);
}</span>
#else
void PrettyUnitTestResultPrinter::OnTestSuiteEnd(const TestSuite&amp; test_suite) {
  if (!GTEST_FLAG(print_time)) return;

  const std::string counts =
      FormatCountableNoun(test_suite.test_to_run_count(), "test", "tests");
  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("%s from %s (%s ms total)\n\n", counts.c_str(), test_suite.name(),
         internal::StreamableToString(test_suite.elapsed_time()).c_str());
  fflush(stdout);
}
#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_

void PrettyUnitTestResultPrinter::OnEnvironmentsTearDownStart(
<span style = "background-color:#dfd">    const UnitTest&amp; /*unit_test*/) {
  ColoredPrintf(GTestColor::kGreen, "[----------] ");
  printf("Global test environment tear-down\n");
  fflush(stdout);
}</span>

// Internal helper for printing the list of failed tests.
<span style = "background-color:#fdd">void PrettyUnitTestResultPrinter::PrintFailedTests(const UnitTest&amp; unit_test) {
  const int failed_test_count = unit_test.failed_test_count();
  ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
  printf("%s, listed below:\n", FormatTestCount(failed_test_count).c_str());</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {
    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);
    if (!test_suite.should_run() || (test_suite.failed_test_count() == 0)) {
      continue;</span>
    }
<span style = "background-color:#fdd">    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {
      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);
      if (!test_info.should_run() || !test_info.result()-&gt;Failed()) {
        continue;</span>
      }
<span style = "background-color:#fdd">      ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
      printf("%s.%s", test_suite.name(), test_info.name());
      PrintFullTestCommentIfPresent(test_info);
      printf("\n");
    }
  }
  printf("\n%2d FAILED %s\n", failed_test_count,</span>
         failed_test_count == 1 ? "TEST" : "TESTS");
<span style = "background-color:#fdd">}</span>

// Internal helper for printing the list of test suite failures not covered by
// PrintFailedTests.
void PrettyUnitTestResultPrinter::PrintFailedTestSuites(
<span style = "background-color:#fdd">    const UnitTest&amp; unit_test) {
  int suite_failure_count = 0;
  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {
    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);
    if (!test_suite.should_run()) {
      continue;</span>
    }
<span style = "background-color:#fdd">    if (test_suite.ad_hoc_test_result().Failed()) {
      ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
      printf("%s: SetUpTestSuite or TearDownTestSuite\n", test_suite.name());
      ++suite_failure_count;</span>
    }
<span style = "background-color:#fdd">  }
  if (suite_failure_count &gt; 0) {
    printf("\n%2d FAILED TEST %s\n", suite_failure_count,</span>
           suite_failure_count == 1 ? "SUITE" : "SUITES");
  }
<span style = "background-color:#fdd">}</span>

// Internal helper for printing the list of skipped tests.
<span style = "background-color:#fdd">void PrettyUnitTestResultPrinter::PrintSkippedTests(const UnitTest&amp; unit_test) {
  const int skipped_test_count = unit_test.skipped_test_count();
  if (skipped_test_count == 0) {
    return;</span>
  }

<span style = "background-color:#fdd">  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {
    const TestSuite&amp; test_suite = *unit_test.GetTestSuite(i);
    if (!test_suite.should_run() || (test_suite.skipped_test_count() == 0)) {
      continue;</span>
    }
<span style = "background-color:#fdd">    for (int j = 0; j &lt; test_suite.total_test_count(); ++j) {
      const TestInfo&amp; test_info = *test_suite.GetTestInfo(j);
      if (!test_info.should_run() || !test_info.result()-&gt;Skipped()) {
        continue;</span>
      }
<span style = "background-color:#fdd">      ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
      printf("%s.%s", test_suite.name(), test_info.name());
      printf("\n");
    }
  }
}</span>

void PrettyUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,
<span style = "background-color:#dfd">                                                     int /*iteration*/) {
  ColoredPrintf(GTestColor::kGreen, "[==========] ");
  printf("%s from %s ran.",</span>
         FormatTestCount(unit_test.test_to_run_count()).c_str(),
         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
<span style = "background-color:#dfd">  if (GTEST_FLAG(print_time)) {
    printf(" (%s ms total)",</span>
           internal::StreamableToString(unit_test.elapsed_time()).c_str());
  }
<span style = "background-color:#dfd">  printf("\n");
  ColoredPrintf(GTestColor::kGreen, "[  PASSED  ] ");
  printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());</span>

<span style = "background-color:#dfd">  const int skipped_test_count = unit_test.skipped_test_count();
  if (skipped_test_count &gt; 0) {</span>
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    printf("%s, listed below:\n", FormatTestCount(skipped_test_count).c_str());
    PrintSkippedTests(unit_test);</span>
  }

<span style = "background-color:#dfd">  if (!unit_test.Passed()) {</span>
<span style = "background-color:#fdd">    PrintFailedTests(unit_test);
    PrintFailedTestSuites(unit_test);</span>
  }

<span style = "background-color:#dfd">  int num_disabled = unit_test.reportable_disabled_test_count();
  if (num_disabled &amp;&amp; !GTEST_FLAG(also_run_disabled_tests)) {</span>
<span style = "background-color:#fdd">    if (unit_test.Passed()) {
      printf("\n");  // Add a spacer if no FAILURE banner is displayed.</span>
    }
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kYellow, "  YOU HAVE %d DISABLED %s\n\n",</span>
                  num_disabled, num_disabled == 1 ? "TEST" : "TESTS");
  }
  // Ensure that Google Test output is printed before, e.g., heapchecker output.
<span style = "background-color:#dfd">  fflush(stdout);
}</span>

// End PrettyUnitTestResultPrinter

// This class implements the TestEventListener interface.
//
// Class BriefUnitTestResultPrinter is copyable.
class BriefUnitTestResultPrinter : public TestEventListener {
 public:
<span style = "background-color:#fdd">  BriefUnitTestResultPrinter() {}
  static void PrintTestName(const char* test_suite, const char* test) {
    printf("%s.%s", test_suite, test);
  }</span>

  // The following methods override what's in the TestEventListener class.
<span style = "background-color:#fdd">  void OnTestProgramStart(const UnitTest&amp; /*unit_test*/) override {}</span>
  void OnTestIterationStart(const UnitTest&amp; /*unit_test*/,
<span style = "background-color:#fdd">                            int /*iteration*/) override {}
  void OnEnvironmentsSetUpStart(const UnitTest&amp; /*unit_test*/) override {}
  void OnEnvironmentsSetUpEnd(const UnitTest&amp; /*unit_test*/) override {}</span>
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">  void OnTestCaseStart(const TestCase&amp; /*test_case*/) override {}</span>
#else
  void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override {}
#endif  // OnTestCaseStart

<span style = "background-color:#fdd">  void OnTestStart(const TestInfo&amp; /*test_info*/) override {}</span>

  void OnTestPartResult(const TestPartResult&amp; result) override;
  void OnTestEnd(const TestInfo&amp; test_info) override;
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">  void OnTestCaseEnd(const TestCase&amp; /*test_case*/) override {}</span>
#else
  void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override {}
#endif  // GTEST_REMOVE_LEGACY_TEST_CASEAPI_

<span style = "background-color:#fdd">  void OnEnvironmentsTearDownStart(const UnitTest&amp; /*unit_test*/) override {}
  void OnEnvironmentsTearDownEnd(const UnitTest&amp; /*unit_test*/) override {}</span>
  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;
<span style = "background-color:#fdd">  void OnTestProgramEnd(const UnitTest&amp; /*unit_test*/) override {}</span>
};

// Called after an assertion failure.
void BriefUnitTestResultPrinter::OnTestPartResult(
<span style = "background-color:#fdd">    const TestPartResult&amp; result) {
  switch (result.type()) {</span>
    // If the test part succeeded, we don't need to do anything.
    case TestPartResult::kSuccess:
<span style = "background-color:#fdd">      return;</span>
    default:
      // Print failure message from the assertion
      // (e.g. expected this and got that).
<span style = "background-color:#fdd">      PrintTestPartResult(result);
      fflush(stdout);</span>
  }
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">void BriefUnitTestResultPrinter::OnTestEnd(const TestInfo&amp; test_info) {
  if (test_info.result()-&gt;Failed()) {
    ColoredPrintf(GTestColor::kRed, "[  FAILED  ] ");
    PrintTestName(test_info.test_suite_name(), test_info.name());
    PrintFullTestCommentIfPresent(test_info);</span>

<span style = "background-color:#fdd">    if (GTEST_FLAG(print_time)) {
      printf(" (%s ms)\n",</span>
             internal::StreamableToString(test_info.result()-&gt;elapsed_time())
                 .c_str());
<span style = "background-color:#fdd">    } else {
      printf("\n");</span>
    }
<span style = "background-color:#fdd">    fflush(stdout);</span>
  }
<span style = "background-color:#fdd">}</span>

void BriefUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,
<span style = "background-color:#fdd">                                                    int /*iteration*/) {
  ColoredPrintf(GTestColor::kGreen, "[==========] ");
  printf("%s from %s ran.",</span>
         FormatTestCount(unit_test.test_to_run_count()).c_str(),
         FormatTestSuiteCount(unit_test.test_suite_to_run_count()).c_str());
<span style = "background-color:#fdd">  if (GTEST_FLAG(print_time)) {
    printf(" (%s ms total)",</span>
           internal::StreamableToString(unit_test.elapsed_time()).c_str());
  }
<span style = "background-color:#fdd">  printf("\n");
  ColoredPrintf(GTestColor::kGreen, "[  PASSED  ] ");
  printf("%s.\n", FormatTestCount(unit_test.successful_test_count()).c_str());</span>

<span style = "background-color:#fdd">  const int skipped_test_count = unit_test.skipped_test_count();
  if (skipped_test_count &gt; 0) {
    ColoredPrintf(GTestColor::kGreen, "[  SKIPPED ] ");
    printf("%s.\n", FormatTestCount(skipped_test_count).c_str());</span>
  }

<span style = "background-color:#fdd">  int num_disabled = unit_test.reportable_disabled_test_count();
  if (num_disabled &amp;&amp; !GTEST_FLAG(also_run_disabled_tests)) {
    if (unit_test.Passed()) {
      printf("\n");  // Add a spacer if no FAILURE banner is displayed.</span>
    }
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kYellow, "  YOU HAVE %d DISABLED %s\n\n",</span>
                  num_disabled, num_disabled == 1 ? "TEST" : "TESTS");
  }
  // Ensure that Google Test output is printed before, e.g., heapchecker output.
<span style = "background-color:#fdd">  fflush(stdout);
}</span>

// End BriefUnitTestResultPrinter

// class TestEventRepeater
//
// This class forwards events to other event listeners.
class TestEventRepeater : public TestEventListener {
 public:
<span style = "background-color:#dfd">  TestEventRepeater() : forwarding_enabled_(true) {}</span>
  ~TestEventRepeater() override;
  void Append(TestEventListener *listener);
  TestEventListener* Release(TestEventListener* listener);

  // Controls whether events will be forwarded to listeners_. Set to false
  // in death test child processes.
<span style = "background-color:#fdd">  bool forwarding_enabled() const { return forwarding_enabled_; }
  void set_forwarding_enabled(bool enable) { forwarding_enabled_ = enable; }</span>

  void OnTestProgramStart(const UnitTest&amp; unit_test) override;
  void OnTestIterationStart(const UnitTest&amp; unit_test, int iteration) override;
  void OnEnvironmentsSetUpStart(const UnitTest&amp; unit_test) override;
  void OnEnvironmentsSetUpEnd(const UnitTest&amp; unit_test) override;
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestCaseStart(const TestSuite&amp; parameter) override;
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestSuiteStart(const TestSuite&amp; parameter) override;
  void OnTestStart(const TestInfo&amp; test_info) override;
  void OnTestPartResult(const TestPartResult&amp; result) override;
  void OnTestEnd(const TestInfo&amp; test_info) override;
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestCaseEnd(const TestCase&amp; parameter) override;
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
  void OnTestSuiteEnd(const TestSuite&amp; parameter) override;
  void OnEnvironmentsTearDownStart(const UnitTest&amp; unit_test) override;
  void OnEnvironmentsTearDownEnd(const UnitTest&amp; unit_test) override;
  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;
  void OnTestProgramEnd(const UnitTest&amp; unit_test) override;

 private:
  // Controls whether events will be forwarded to listeners_. Set to false
  // in death test child processes.
  bool forwarding_enabled_;
  // The list of listeners that receive events.
  std::vector&lt;TestEventListener*&gt; listeners_;

  GTEST_DISALLOW_COPY_AND_ASSIGN_(TestEventRepeater);
};

<span style = "background-color:#dfd">TestEventRepeater::~TestEventRepeater() {
  ForEach(listeners_, Delete&lt;TestEventListener&gt;);
}</span>

<span style = "background-color:#dfd">void TestEventRepeater::Append(TestEventListener *listener) {
  listeners_.push_back(listener);
}</span>

<span style = "background-color:#dfd">TestEventListener* TestEventRepeater::Release(TestEventListener *listener) {
  for (size_t i = 0; i &lt; listeners_.size(); ++i) {</span>
<span style = "background-color:#fdd">    if (listeners_[i] == listener) {
      listeners_.erase(listeners_.begin() + static_cast&lt;int&gt;(i));
      return listener;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#dfd">  return nullptr;
}</span>

// Since most methods are very similar, use macros to reduce boilerplate.
// This defines a member that forwards the call to all listeners.
#define GTEST_REPEATER_METHOD_(Name, Type) \
void TestEventRepeater::Name(const Type&amp; parameter) { \
  if (forwarding_enabled_) { \
    for (size_t i = 0; i &lt; listeners_.size(); i++) { \
      listeners_[i]-&gt;Name(parameter); \
    } \
  } \
}
// This defines a member that forwards the call to all listeners in reverse
// order.
#define GTEST_REVERSE_REPEATER_METHOD_(Name, Type)      \
  void TestEventRepeater::Name(const Type&amp; parameter) { \
    if (forwarding_enabled_) {                          \
      for (size_t i = listeners_.size(); i != 0; i--) { \
        listeners_[i - 1]-&gt;Name(parameter);             \
      }                                                 \
    }                                                   \
  }

<span style = "background-color:#dfd">GTEST_REPEATER_METHOD_(OnTestProgramStart, UnitTest)
GTEST_REPEATER_METHOD_(OnEnvironmentsSetUpStart, UnitTest)</span>
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">GTEST_REPEATER_METHOD_(OnTestCaseStart, TestSuite)</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">GTEST_REPEATER_METHOD_(OnTestSuiteStart, TestSuite)
GTEST_REPEATER_METHOD_(OnTestStart, TestInfo)</span>
<span style = "background-color:#fdd">GTEST_REPEATER_METHOD_(OnTestPartResult, TestPartResult)</span>
<span style = "background-color:#dfd">GTEST_REPEATER_METHOD_(OnEnvironmentsTearDownStart, UnitTest)
GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsSetUpEnd, UnitTest)
GTEST_REVERSE_REPEATER_METHOD_(OnEnvironmentsTearDownEnd, UnitTest)
GTEST_REVERSE_REPEATER_METHOD_(OnTestEnd, TestInfo)</span>
//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">GTEST_REVERSE_REPEATER_METHOD_(OnTestCaseEnd, TestSuite)</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#dfd">GTEST_REVERSE_REPEATER_METHOD_(OnTestSuiteEnd, TestSuite)
GTEST_REVERSE_REPEATER_METHOD_(OnTestProgramEnd, UnitTest)</span>

#undef GTEST_REPEATER_METHOD_
#undef GTEST_REVERSE_REPEATER_METHOD_

void TestEventRepeater::OnTestIterationStart(const UnitTest&amp; unit_test,
<span style = "background-color:#dfd">                                             int iteration) {
  if (forwarding_enabled_) {
    for (size_t i = 0; i &lt; listeners_.size(); i++) {
      listeners_[i]-&gt;OnTestIterationStart(unit_test, iteration);
    }</span>
  }
<span style = "background-color:#dfd">}</span>

void TestEventRepeater::OnTestIterationEnd(const UnitTest&amp; unit_test,
<span style = "background-color:#dfd">                                           int iteration) {
  if (forwarding_enabled_) {
    for (size_t i = listeners_.size(); i &gt; 0; i--) {
      listeners_[i - 1]-&gt;OnTestIterationEnd(unit_test, iteration);
    }</span>
  }
<span style = "background-color:#dfd">}</span>

// End TestEventRepeater

// This class generates an XML output file.
class XmlUnitTestResultPrinter : public EmptyTestEventListener {
 public:
  explicit XmlUnitTestResultPrinter(const char* output_file);

  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;
  void ListTestsMatchingFilter(const std::vector&lt;TestSuite*&gt;&amp; test_suites);

  // Prints an XML summary of all unit tests.
  static void PrintXmlTestsList(std::ostream* stream,
                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);

 private:
  // Is c a whitespace character that is normalized to a space character
  // when it appears in an XML attribute value?
<span style = "background-color:#fdd">  static bool IsNormalizableWhitespace(char c) {
    return c == 0x9 || c == 0xA || c == 0xD;
  }</span>

  // May c appear in a well-formed XML document?
<span style = "background-color:#fdd">  static bool IsValidXmlCharacter(char c) {
    return IsNormalizableWhitespace(c) || c &gt;= 0x20;
  }</span>

  // Returns an XML-escaped copy of the input string str.  If
  // is_attribute is true, the text is meant to appear as an attribute
  // value, and normalizable whitespace is preserved by replacing it
  // with character references.
  static std::string EscapeXml(const std::string&amp; str, bool is_attribute);

  // Returns the given string with all characters invalid in XML removed.
  static std::string RemoveInvalidXmlCharacters(const std::string&amp; str);

  // Convenience wrapper around EscapeXml when str is an attribute value.
<span style = "background-color:#fdd">  static std::string EscapeXmlAttribute(const std::string&amp; str) {
    return EscapeXml(str, true);
  }</span>

  // Convenience wrapper around EscapeXml when str is not an attribute value.
  static std::string EscapeXmlText(const char* str) {
    return EscapeXml(str, false);
  }

  // Verifies that the given attribute belongs to the given element and
  // streams the attribute as XML.
  static void OutputXmlAttribute(std::ostream* stream,
                                 const std::string&amp; element_name,
                                 const std::string&amp; name,
                                 const std::string&amp; value);

  // Streams an XML CDATA section, escaping invalid CDATA sequences as needed.
  static void OutputXmlCDataSection(::std::ostream* stream, const char* data);

  // Streams a test suite XML stanza containing the given test result.
  //
  // Requires: result.Failed()
  static void OutputXmlTestSuiteForTestResult(::std::ostream* stream,
                                              const TestResult&amp; result);

  // Streams an XML representation of a TestResult object.
  static void OutputXmlTestResult(::std::ostream* stream,
                                  const TestResult&amp; result);

  // Streams an XML representation of a TestInfo object.
  static void OutputXmlTestInfo(::std::ostream* stream,
                                const char* test_suite_name,
                                const TestInfo&amp; test_info);

  // Prints an XML representation of a TestSuite object
  static void PrintXmlTestSuite(::std::ostream* stream,
                                const TestSuite&amp; test_suite);

  // Prints an XML summary of unit_test to output stream out.
  static void PrintXmlUnitTest(::std::ostream* stream,
                               const UnitTest&amp; unit_test);

  // Produces a string representing the test properties in a result as space
  // delimited XML attributes based on the property key="value" pairs.
  // When the std::string is not empty, it includes a space at the beginning,
  // to delimit this attribute from prior attributes.
  static std::string TestPropertiesAsXmlAttributes(const TestResult&amp; result);

  // Streams an XML representation of the test properties of a TestResult
  // object.
  static void OutputXmlTestProperties(std::ostream* stream,
                                      const TestResult&amp; result);

  // The output file.
  const std::string output_file_;

  GTEST_DISALLOW_COPY_AND_ASSIGN_(XmlUnitTestResultPrinter);
};

// Creates a new XmlUnitTestResultPrinter.
XmlUnitTestResultPrinter::XmlUnitTestResultPrinter(const char* output_file)
<span style = "background-color:#fdd">    : output_file_(output_file) {
  if (output_file_.empty()) {
    GTEST_LOG_(FATAL) &lt;&lt; "XML output file may not be null";</span>
  }
<span style = "background-color:#fdd">}</span>

// Called after the unit test ends.
void XmlUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,
<span style = "background-color:#fdd">                                                  int /*iteration*/) {
  FILE* xmlout = OpenFileForWriting(output_file_);
  std::stringstream stream;
  PrintXmlUnitTest(&amp;stream, unit_test);
  fprintf(xmlout, "%s", StringStreamToString(&amp;stream).c_str());
  fclose(xmlout);
}</span>

void XmlUnitTestResultPrinter::ListTestsMatchingFilter(
<span style = "background-color:#fdd">    const std::vector&lt;TestSuite*&gt;&amp; test_suites) {
  FILE* xmlout = OpenFileForWriting(output_file_);
  std::stringstream stream;
  PrintXmlTestsList(&amp;stream, test_suites);
  fprintf(xmlout, "%s", StringStreamToString(&amp;stream).c_str());
  fclose(xmlout);
}</span>

// Returns an XML-escaped copy of the input string str.  If is_attribute
// is true, the text is meant to appear as an attribute value, and
// normalizable whitespace is preserved by replacing it with character
// references.
//
// Invalid XML characters in str, if any, are stripped from the output.
// It is expected that most, if not all, of the text processed by this
// module will consist of ordinary English text.
// If this module is ever modified to produce version 1.1 XML output,
// most invalid characters can be retained using character references.
std::string XmlUnitTestResultPrinter::EscapeXml(
<span style = "background-color:#fdd">    const std::string&amp; str, bool is_attribute) {
  Message m;</span>

<span style = "background-color:#fdd">  for (size_t i = 0; i &lt; str.size(); ++i) {
    const char ch = str[i];
    switch (ch) {</span>
      case '&lt;':
<span style = "background-color:#fdd">        m &lt;&lt; "&amp;lt;";
        break;</span>
      case '&gt;':
<span style = "background-color:#fdd">        m &lt;&lt; "&amp;gt;";
        break;</span>
      case '&amp;':
<span style = "background-color:#fdd">        m &lt;&lt; "&amp;amp;";
        break;</span>
      case '\'':
<span style = "background-color:#fdd">        if (is_attribute)
          m &lt;&lt; "&amp;apos;";</span>
        else
<span style = "background-color:#fdd">          m &lt;&lt; '\'';
        break;</span>
      case '"':
<span style = "background-color:#fdd">        if (is_attribute)
          m &lt;&lt; "&amp;quot;";</span>
        else
<span style = "background-color:#fdd">          m &lt;&lt; '"';
        break;</span>
      default:
<span style = "background-color:#fdd">        if (IsValidXmlCharacter(ch)) {
          if (is_attribute &amp;&amp; IsNormalizableWhitespace(ch))
            m &lt;&lt; "&amp;#x" &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch))</span>
              &lt;&lt; ";";
          else
<span style = "background-color:#fdd">            m &lt;&lt; ch;</span>
        }
        break;
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return m.GetString();
}</span>

// Returns the given string with all characters invalid in XML removed.
// Currently invalid characters are dropped from the string. An
// alternative is to replace them with certain characters such as . or ?.
std::string XmlUnitTestResultPrinter::RemoveInvalidXmlCharacters(
<span style = "background-color:#fdd">    const std::string&amp; str) {
  std::string output;
  output.reserve(str.size());
  for (std::string::const_iterator it = str.begin(); it != str.end(); ++it)
    if (IsValidXmlCharacter(*it))
      output.push_back(*it);</span>

<span style = "background-color:#fdd">  return output;
}</span>

// The following routines generate an XML representation of a UnitTest
// object.
// GOOGLETEST_CM0009 DO NOT DELETE
//
// This is how Google Test concepts map to the DTD:
//
// &lt;testsuites name="AllTests"&gt;        &lt;-- corresponds to a UnitTest object
//   &lt;testsuite name="testcase-name"&gt;  &lt;-- corresponds to a TestSuite object
//     &lt;testcase name="test-name"&gt;     &lt;-- corresponds to a TestInfo object
//       &lt;failure message="..."&gt;...&lt;/failure&gt;
//       &lt;failure message="..."&gt;...&lt;/failure&gt;
//       &lt;failure message="..."&gt;...&lt;/failure&gt;
//                                     &lt;-- individual assertion failures
//     &lt;/testcase&gt;
//   &lt;/testsuite&gt;
// &lt;/testsuites&gt;

// Formats the given time in milliseconds as seconds.
<span style = "background-color:#fdd">std::string FormatTimeInMillisAsSeconds(TimeInMillis ms) {
  ::std::stringstream ss;
  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3);
  return ss.str();
}</span>

<span style = "background-color:#fdd">static bool PortableLocaltime(time_t seconds, struct tm* out) {</span>
#if defined(_MSC_VER)
<span style = "background-color:#fdd">  return localtime_s(out, &amp;seconds) == 0;</span>
#elif defined(__MINGW32__) || defined(__MINGW64__)
  // MINGW &lt;time.h&gt; provides neither localtime_r nor localtime_s, but uses
  // Windows' localtime(), which has a thread-local tm buffer.
  struct tm* tm_ptr = localtime(&amp;seconds);  // NOLINT
  if (tm_ptr == nullptr) return false;
  *out = *tm_ptr;
  return true;
#elif defined(__STDC_LIB_EXT1__)
  // Uses localtime_s when available as localtime_r is only available from
  // C23 standard.
  return localtime_s(&amp;seconds, out) != nullptr;
#else
  return localtime_r(&amp;seconds, out) != nullptr;
#endif
<span style = "background-color:#fdd">}</span>

// Converts the given epoch time in milliseconds to a date string in the ISO
// 8601 format, without the timezone information.
<span style = "background-color:#fdd">std::string FormatEpochTimeInMillisAsIso8601(TimeInMillis ms) {</span>
  struct tm time_struct;
<span style = "background-color:#fdd">  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))
    return "";</span>
  // YYYY-MM-DDThh:mm:ss.sss
<span style = "background-color:#fdd">  return StreamableToString(time_struct.tm_year + 1900) + "-" +</span>
      String::FormatIntWidth2(time_struct.tm_mon + 1) + "-" +
      String::FormatIntWidth2(time_struct.tm_mday) + "T" +
      String::FormatIntWidth2(time_struct.tm_hour) + ":" +
      String::FormatIntWidth2(time_struct.tm_min) + ":" +
      String::FormatIntWidth2(time_struct.tm_sec) + "." +
      String::FormatIntWidthN(static_cast&lt;int&gt;(ms % 1000), 3);
<span style = "background-color:#fdd">}</span>

// Streams an XML CDATA section, escaping invalid CDATA sequences as needed.
void XmlUnitTestResultPrinter::OutputXmlCDataSection(::std::ostream* stream,
<span style = "background-color:#fdd">                                                     const char* data) {
  const char* segment = data;
  *stream &lt;&lt; "&lt;![CDATA[";</span>
  for (;;) {
<span style = "background-color:#fdd">    const char* const next_segment = strstr(segment, "]]&gt;");
    if (next_segment != nullptr) {
      stream-&gt;write(</span>
          segment, static_cast&lt;std::streamsize&gt;(next_segment - segment));
<span style = "background-color:#fdd">      *stream &lt;&lt; "]]&gt;]]&amp;gt;&lt;![CDATA[";
      segment = next_segment + strlen("]]&gt;");
    } else {
      *stream &lt;&lt; segment;
      break;</span>
    }
<span style = "background-color:#fdd">  }
  *stream &lt;&lt; "]]&gt;";
}</span>

void XmlUnitTestResultPrinter::OutputXmlAttribute(
    std::ostream* stream,
    const std::string&amp; element_name,
    const std::string&amp; name,
<span style = "background-color:#fdd">    const std::string&amp; value) {
  const std::vector&lt;std::string&gt;&amp; allowed_names =</span>
      GetReservedOutputAttributesForElement(element_name);

<span style = "background-color:#fdd">  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=</span>
                   allowed_names.end())
      &lt;&lt; "Attribute " &lt;&lt; name &lt;&lt; " is not allowed for element &lt;" &lt;&lt; element_name
      &lt;&lt; "&gt;.";

<span style = "background-color:#fdd">  *stream &lt;&lt; " " &lt;&lt; name &lt;&lt; "=\"" &lt;&lt; EscapeXmlAttribute(value) &lt;&lt; "\"";
}</span>

// Streams a test suite XML stanza containing the given test result.
void XmlUnitTestResultPrinter::OutputXmlTestSuiteForTestResult(
<span style = "background-color:#fdd">    ::std::ostream* stream, const TestResult&amp; result) {</span>
  // Output the boilerplate for a minimal test suite with one test.
<span style = "background-color:#fdd">  *stream &lt;&lt; "  &lt;testsuite";
  OutputXmlAttribute(stream, "testsuite", "name", "NonTestSuiteFailure");
  OutputXmlAttribute(stream, "testsuite", "tests", "1");
  OutputXmlAttribute(stream, "testsuite", "failures", "1");
  OutputXmlAttribute(stream, "testsuite", "disabled", "0");
  OutputXmlAttribute(stream, "testsuite", "skipped", "0");
  OutputXmlAttribute(stream, "testsuite", "errors", "0");
  OutputXmlAttribute(stream, "testsuite", "time",</span>
                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
<span style = "background-color:#fdd">  OutputXmlAttribute(</span>
      stream, "testsuite", "timestamp",
      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));
<span style = "background-color:#fdd">  *stream &lt;&lt; "&gt;";</span>

  // Output the boilerplate for a minimal test case with a single test.
<span style = "background-color:#fdd">  *stream &lt;&lt; "    &lt;testcase";
  OutputXmlAttribute(stream, "testcase", "name", "");
  OutputXmlAttribute(stream, "testcase", "status", "run");
  OutputXmlAttribute(stream, "testcase", "result", "completed");
  OutputXmlAttribute(stream, "testcase", "classname", "");
  OutputXmlAttribute(stream, "testcase", "time",</span>
                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
<span style = "background-color:#fdd">  OutputXmlAttribute(</span>
      stream, "testcase", "timestamp",
      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));

  // Output the actual test result.
<span style = "background-color:#fdd">  OutputXmlTestResult(stream, result);</span>

  // Complete the test suite.
<span style = "background-color:#fdd">  *stream &lt;&lt; "  &lt;/testsuite&gt;\n";
}</span>

// Prints an XML representation of a TestInfo object.
void XmlUnitTestResultPrinter::OutputXmlTestInfo(::std::ostream* stream,
                                                 const char* test_suite_name,
<span style = "background-color:#fdd">                                                 const TestInfo&amp; test_info) {
  const TestResult&amp; result = *test_info.result();
  const std::string kTestsuite = "testcase";</span>

<span style = "background-color:#fdd">  if (test_info.is_in_another_shard()) {
    return;</span>
  }

<span style = "background-color:#fdd">  *stream &lt;&lt; "    &lt;testcase";
  OutputXmlAttribute(stream, kTestsuite, "name", test_info.name());</span>

<span style = "background-color:#fdd">  if (test_info.value_param() != nullptr) {
    OutputXmlAttribute(stream, kTestsuite, "value_param",</span>
                       test_info.value_param());
  }
<span style = "background-color:#fdd">  if (test_info.type_param() != nullptr) {
    OutputXmlAttribute(stream, kTestsuite, "type_param",</span>
                       test_info.type_param());
  }
<span style = "background-color:#fdd">  if (GTEST_FLAG(list_tests)) {
    OutputXmlAttribute(stream, kTestsuite, "file", test_info.file());
    OutputXmlAttribute(stream, kTestsuite, "line",</span>
                       StreamableToString(test_info.line()));
<span style = "background-color:#fdd">    *stream &lt;&lt; " /&gt;\n";
    return;</span>
  }

<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuite, "status",</span>
                     test_info.should_run() ? "run" : "notrun");
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuite, "result",</span>
                     test_info.should_run()
                         ? (result.Skipped() ? "skipped" : "completed")
                         : "suppressed");
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuite, "time",</span>
                     FormatTimeInMillisAsSeconds(result.elapsed_time()));
<span style = "background-color:#fdd">  OutputXmlAttribute(</span>
      stream, kTestsuite, "timestamp",
      FormatEpochTimeInMillisAsIso8601(result.start_timestamp()));
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuite, "classname", test_suite_name);</span>

<span style = "background-color:#fdd">  OutputXmlTestResult(stream, result);
}</span>

void XmlUnitTestResultPrinter::OutputXmlTestResult(::std::ostream* stream,
<span style = "background-color:#fdd">                                                   const TestResult&amp; result) {
  int failures = 0;
  int skips = 0;
  for (int i = 0; i &lt; result.total_part_count(); ++i) {
    const TestPartResult&amp; part = result.GetTestPartResult(i);
    if (part.failed()) {
      if (++failures == 1 &amp;&amp; skips == 0) {
        *stream &lt;&lt; "&gt;\n";</span>
      }
<span style = "background-color:#fdd">      const std::string location =</span>
          internal::FormatCompilerIndependentFileLocation(part.file_name(),
                                                          part.line_number());
<span style = "background-color:#fdd">      const std::string summary = location + "\n" + part.summary();
      *stream &lt;&lt; "      &lt;failure message=\""</span>
              &lt;&lt; EscapeXmlAttribute(summary)
              &lt;&lt; "\" type=\"\"&gt;";
<span style = "background-color:#fdd">      const std::string detail = location + "\n" + part.message();
      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
      *stream &lt;&lt; "&lt;/failure&gt;\n";
    } else if (part.skipped()) {
      if (++skips == 1 &amp;&amp; failures == 0) {
        *stream &lt;&lt; "&gt;\n";</span>
      }
<span style = "background-color:#fdd">      const std::string location =</span>
          internal::FormatCompilerIndependentFileLocation(part.file_name(),
                                                          part.line_number());
<span style = "background-color:#fdd">      const std::string summary = location + "\n" + part.summary();
      *stream &lt;&lt; "      &lt;skipped message=\""</span>
              &lt;&lt; EscapeXmlAttribute(summary.c_str()) &lt;&lt; "\"&gt;";
<span style = "background-color:#fdd">      const std::string detail = location + "\n" + part.message();
      OutputXmlCDataSection(stream, RemoveInvalidXmlCharacters(detail).c_str());
      *stream &lt;&lt; "&lt;/skipped&gt;\n";
    }
  }</span>

<span style = "background-color:#fdd">  if (failures == 0 &amp;&amp; skips == 0 &amp;&amp; result.test_property_count() == 0) {
    *stream &lt;&lt; " /&gt;\n";
  } else {
    if (failures == 0 &amp;&amp; skips == 0) {
      *stream &lt;&lt; "&gt;\n";</span>
    }
<span style = "background-color:#fdd">    OutputXmlTestProperties(stream, result);
    *stream &lt;&lt; "    &lt;/testcase&gt;\n";</span>
  }
<span style = "background-color:#fdd">}</span>

// Prints an XML representation of a TestSuite object
void XmlUnitTestResultPrinter::PrintXmlTestSuite(std::ostream* stream,
<span style = "background-color:#fdd">                                                 const TestSuite&amp; test_suite) {
  const std::string kTestsuite = "testsuite";
  *stream &lt;&lt; "  &lt;" &lt;&lt; kTestsuite;
  OutputXmlAttribute(stream, kTestsuite, "name", test_suite.name());
  OutputXmlAttribute(stream, kTestsuite, "tests",</span>
                     StreamableToString(test_suite.reportable_test_count()));
<span style = "background-color:#fdd">  if (!GTEST_FLAG(list_tests)) {
    OutputXmlAttribute(stream, kTestsuite, "failures",</span>
                       StreamableToString(test_suite.failed_test_count()));
<span style = "background-color:#fdd">    OutputXmlAttribute(</span>
        stream, kTestsuite, "disabled",
        StreamableToString(test_suite.reportable_disabled_test_count()));
<span style = "background-color:#fdd">    OutputXmlAttribute(stream, kTestsuite, "skipped",</span>
                       StreamableToString(test_suite.skipped_test_count()));

<span style = "background-color:#fdd">    OutputXmlAttribute(stream, kTestsuite, "errors", "0");</span>

<span style = "background-color:#fdd">    OutputXmlAttribute(stream, kTestsuite, "time",</span>
                       FormatTimeInMillisAsSeconds(test_suite.elapsed_time()));
<span style = "background-color:#fdd">    OutputXmlAttribute(</span>
        stream, kTestsuite, "timestamp",
        FormatEpochTimeInMillisAsIso8601(test_suite.start_timestamp()));
<span style = "background-color:#fdd">    *stream &lt;&lt; TestPropertiesAsXmlAttributes(test_suite.ad_hoc_test_result());</span>
  }
<span style = "background-color:#fdd">  *stream &lt;&lt; "&gt;\n";
  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {
    if (test_suite.GetTestInfo(i)-&gt;is_reportable())
      OutputXmlTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));
  }
  *stream &lt;&lt; "  &lt;/" &lt;&lt; kTestsuite &lt;&lt; "&gt;\n";
}</span>

// Prints an XML summary of unit_test to output stream out.
void XmlUnitTestResultPrinter::PrintXmlUnitTest(std::ostream* stream,
<span style = "background-color:#fdd">                                                const UnitTest&amp; unit_test) {
  const std::string kTestsuites = "testsuites";</span>

<span style = "background-color:#fdd">  *stream &lt;&lt; "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n";
  *stream &lt;&lt; "&lt;" &lt;&lt; kTestsuites;</span>

<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuites, "tests",</span>
                     StreamableToString(unit_test.reportable_test_count()));
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuites, "failures",</span>
                     StreamableToString(unit_test.failed_test_count()));
<span style = "background-color:#fdd">  OutputXmlAttribute(</span>
      stream, kTestsuites, "disabled",
      StreamableToString(unit_test.reportable_disabled_test_count()));
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuites, "errors", "0");
  OutputXmlAttribute(stream, kTestsuites, "time",</span>
                     FormatTimeInMillisAsSeconds(unit_test.elapsed_time()));
<span style = "background-color:#fdd">  OutputXmlAttribute(</span>
      stream, kTestsuites, "timestamp",
      FormatEpochTimeInMillisAsIso8601(unit_test.start_timestamp()));

<span style = "background-color:#fdd">  if (GTEST_FLAG(shuffle)) {
    OutputXmlAttribute(stream, kTestsuites, "random_seed",</span>
                       StreamableToString(unit_test.random_seed()));
  }
<span style = "background-color:#fdd">  *stream &lt;&lt; TestPropertiesAsXmlAttributes(unit_test.ad_hoc_test_result());</span>

<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
  *stream &lt;&lt; "&gt;\n";</span>

<span style = "background-color:#fdd">  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {
    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0)
      PrintXmlTestSuite(stream, *unit_test.GetTestSuite(i));
  }</span>

  // If there was a test failure outside of one of the test suites (like in a
  // test environment) include that in the output.
<span style = "background-color:#fdd">  if (unit_test.ad_hoc_test_result().Failed()) {
    OutputXmlTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());</span>
  }

<span style = "background-color:#fdd">  *stream &lt;&lt; "&lt;/" &lt;&lt; kTestsuites &lt;&lt; "&gt;\n";
}</span>

void XmlUnitTestResultPrinter::PrintXmlTestsList(
<span style = "background-color:#fdd">    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {
  const std::string kTestsuites = "testsuites";</span>

<span style = "background-color:#fdd">  *stream &lt;&lt; "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n";
  *stream &lt;&lt; "&lt;" &lt;&lt; kTestsuites;</span>

<span style = "background-color:#fdd">  int total_tests = 0;
  for (auto test_suite : test_suites) {
    total_tests += test_suite-&gt;total_test_count();
  }
  OutputXmlAttribute(stream, kTestsuites, "tests",</span>
                     StreamableToString(total_tests));
<span style = "background-color:#fdd">  OutputXmlAttribute(stream, kTestsuites, "name", "AllTests");
  *stream &lt;&lt; "&gt;\n";</span>

<span style = "background-color:#fdd">  for (auto test_suite : test_suites) {
    PrintXmlTestSuite(stream, *test_suite);
  }
  *stream &lt;&lt; "&lt;/" &lt;&lt; kTestsuites &lt;&lt; "&gt;\n";
}</span>

// Produces a string representing the test properties in a result as space
// delimited XML attributes based on the property key="value" pairs.
std::string XmlUnitTestResultPrinter::TestPropertiesAsXmlAttributes(
<span style = "background-color:#fdd">    const TestResult&amp; result) {
  Message attributes;
  for (int i = 0; i &lt; result.test_property_count(); ++i) {
    const TestProperty&amp; property = result.GetTestProperty(i);
    attributes &lt;&lt; " " &lt;&lt; property.key() &lt;&lt; "="</span>
        &lt;&lt; "\"" &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; "\"";
<span style = "background-color:#fdd">  }
  return attributes.GetString();
}</span>

void XmlUnitTestResultPrinter::OutputXmlTestProperties(
<span style = "background-color:#fdd">    std::ostream* stream, const TestResult&amp; result) {
  const std::string kProperties = "properties";
  const std::string kProperty = "property";</span>

<span style = "background-color:#fdd">  if (result.test_property_count() &lt;= 0) {
    return;</span>
  }

<span style = "background-color:#fdd">  *stream &lt;&lt; "&lt;" &lt;&lt; kProperties &lt;&lt; "&gt;\n";
  for (int i = 0; i &lt; result.test_property_count(); ++i) {
    const TestProperty&amp; property = result.GetTestProperty(i);
    *stream &lt;&lt; "&lt;" &lt;&lt; kProperty;
    *stream &lt;&lt; " name=\"" &lt;&lt; EscapeXmlAttribute(property.key()) &lt;&lt; "\"";
    *stream &lt;&lt; " value=\"" &lt;&lt; EscapeXmlAttribute(property.value()) &lt;&lt; "\"";
    *stream &lt;&lt; "/&gt;\n";
  }
  *stream &lt;&lt; "&lt;/" &lt;&lt; kProperties &lt;&lt; "&gt;\n";
}</span>

// End XmlUnitTestResultPrinter

// This class generates an JSON output file.
class JsonUnitTestResultPrinter : public EmptyTestEventListener {
 public:
  explicit JsonUnitTestResultPrinter(const char* output_file);

  void OnTestIterationEnd(const UnitTest&amp; unit_test, int iteration) override;

  // Prints an JSON summary of all unit tests.
  static void PrintJsonTestList(::std::ostream* stream,
                                const std::vector&lt;TestSuite*&gt;&amp; test_suites);

 private:
  // Returns an JSON-escaped copy of the input string str.
  static std::string EscapeJson(const std::string&amp; str);

  //// Verifies that the given attribute belongs to the given element and
  //// streams the attribute as JSON.
  static void OutputJsonKey(std::ostream* stream,
                            const std::string&amp; element_name,
                            const std::string&amp; name,
                            const std::string&amp; value,
                            const std::string&amp; indent,
                            bool comma = true);
  static void OutputJsonKey(std::ostream* stream,
                            const std::string&amp; element_name,
                            const std::string&amp; name,
                            int value,
                            const std::string&amp; indent,
                            bool comma = true);

  // Streams a test suite JSON stanza containing the given test result.
  //
  // Requires: result.Failed()
  static void OutputJsonTestSuiteForTestResult(::std::ostream* stream,
                                               const TestResult&amp; result);

  // Streams a JSON representation of a TestResult object.
  static void OutputJsonTestResult(::std::ostream* stream,
                                   const TestResult&amp; result);

  // Streams a JSON representation of a TestInfo object.
  static void OutputJsonTestInfo(::std::ostream* stream,
                                 const char* test_suite_name,
                                 const TestInfo&amp; test_info);

  // Prints a JSON representation of a TestSuite object
  static void PrintJsonTestSuite(::std::ostream* stream,
                                 const TestSuite&amp; test_suite);

  // Prints a JSON summary of unit_test to output stream out.
  static void PrintJsonUnitTest(::std::ostream* stream,
                                const UnitTest&amp; unit_test);

  // Produces a string representing the test properties in a result as
  // a JSON dictionary.
  static std::string TestPropertiesAsJson(const TestResult&amp; result,
                                          const std::string&amp; indent);

  // The output file.
  const std::string output_file_;

  GTEST_DISALLOW_COPY_AND_ASSIGN_(JsonUnitTestResultPrinter);
};

// Creates a new JsonUnitTestResultPrinter.
JsonUnitTestResultPrinter::JsonUnitTestResultPrinter(const char* output_file)
<span style = "background-color:#fdd">    : output_file_(output_file) {
  if (output_file_.empty()) {
    GTEST_LOG_(FATAL) &lt;&lt; "JSON output file may not be null";</span>
  }
<span style = "background-color:#fdd">}</span>

void JsonUnitTestResultPrinter::OnTestIterationEnd(const UnitTest&amp; unit_test,
<span style = "background-color:#fdd">                                                  int /*iteration*/) {
  FILE* jsonout = OpenFileForWriting(output_file_);
  std::stringstream stream;
  PrintJsonUnitTest(&amp;stream, unit_test);
  fprintf(jsonout, "%s", StringStreamToString(&amp;stream).c_str());
  fclose(jsonout);
}</span>

// Returns an JSON-escaped copy of the input string str.
<span style = "background-color:#fdd">std::string JsonUnitTestResultPrinter::EscapeJson(const std::string&amp; str) {
  Message m;</span>

<span style = "background-color:#fdd">  for (size_t i = 0; i &lt; str.size(); ++i) {
    const char ch = str[i];
    switch (ch) {</span>
      case '\\':
      case '"':
      case '/':
<span style = "background-color:#fdd">        m &lt;&lt; '\\' &lt;&lt; ch;
        break;</span>
      case '\b':
<span style = "background-color:#fdd">        m &lt;&lt; "\\b";
        break;</span>
      case '\t':
<span style = "background-color:#fdd">        m &lt;&lt; "\\t";
        break;</span>
      case '\n':
<span style = "background-color:#fdd">        m &lt;&lt; "\\n";
        break;</span>
      case '\f':
<span style = "background-color:#fdd">        m &lt;&lt; "\\f";
        break;</span>
      case '\r':
<span style = "background-color:#fdd">        m &lt;&lt; "\\r";
        break;</span>
      default:
<span style = "background-color:#fdd">        if (ch &lt; ' ') {
          m &lt;&lt; "\\u00" &lt;&lt; String::FormatByte(static_cast&lt;unsigned char&gt;(ch));
        } else {
          m &lt;&lt; ch;</span>
        }
        break;
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#fdd">  return m.GetString();
}</span>

// The following routines generate an JSON representation of a UnitTest
// object.

// Formats the given time in milliseconds as seconds.
<span style = "background-color:#fdd">static std::string FormatTimeInMillisAsDuration(TimeInMillis ms) {
  ::std::stringstream ss;
  ss &lt;&lt; (static_cast&lt;double&gt;(ms) * 1e-3) &lt;&lt; "s";
  return ss.str();
}</span>

// Converts the given epoch time in milliseconds to a date string in the
// RFC3339 format, without the timezone information.
<span style = "background-color:#fdd">static std::string FormatEpochTimeInMillisAsRFC3339(TimeInMillis ms) {</span>
  struct tm time_struct;
<span style = "background-color:#fdd">  if (!PortableLocaltime(static_cast&lt;time_t&gt;(ms / 1000), &amp;time_struct))
    return "";</span>
  // YYYY-MM-DDThh:mm:ss
<span style = "background-color:#fdd">  return StreamableToString(time_struct.tm_year + 1900) + "-" +</span>
      String::FormatIntWidth2(time_struct.tm_mon + 1) + "-" +
      String::FormatIntWidth2(time_struct.tm_mday) + "T" +
      String::FormatIntWidth2(time_struct.tm_hour) + ":" +
      String::FormatIntWidth2(time_struct.tm_min) + ":" +
      String::FormatIntWidth2(time_struct.tm_sec) + "Z";
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">static inline std::string Indent(size_t width) {
  return std::string(width, ' ');
}</span>

void JsonUnitTestResultPrinter::OutputJsonKey(
    std::ostream* stream,
    const std::string&amp; element_name,
    const std::string&amp; name,
    const std::string&amp; value,
    const std::string&amp; indent,
<span style = "background-color:#fdd">    bool comma) {
  const std::vector&lt;std::string&gt;&amp; allowed_names =</span>
      GetReservedOutputAttributesForElement(element_name);

<span style = "background-color:#fdd">  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=</span>
                   allowed_names.end())
      &lt;&lt; "Key \"" &lt;&lt; name &lt;&lt; "\" is not allowed for value \"" &lt;&lt; element_name
      &lt;&lt; "\".";

<span style = "background-color:#fdd">  *stream &lt;&lt; indent &lt;&lt; "\"" &lt;&lt; name &lt;&lt; "\": \"" &lt;&lt; EscapeJson(value) &lt;&lt; "\"";
  if (comma)
    *stream &lt;&lt; ",\n";
}</span>

void JsonUnitTestResultPrinter::OutputJsonKey(
    std::ostream* stream,
    const std::string&amp; element_name,
    const std::string&amp; name,
    int value,
    const std::string&amp; indent,
<span style = "background-color:#fdd">    bool comma) {
  const std::vector&lt;std::string&gt;&amp; allowed_names =</span>
      GetReservedOutputAttributesForElement(element_name);

<span style = "background-color:#fdd">  GTEST_CHECK_(std::find(allowed_names.begin(), allowed_names.end(), name) !=</span>
                   allowed_names.end())
      &lt;&lt; "Key \"" &lt;&lt; name &lt;&lt; "\" is not allowed for value \"" &lt;&lt; element_name
      &lt;&lt; "\".";

<span style = "background-color:#fdd">  *stream &lt;&lt; indent &lt;&lt; "\"" &lt;&lt; name &lt;&lt; "\": " &lt;&lt; StreamableToString(value);
  if (comma)
    *stream &lt;&lt; ",\n";
}</span>

// Streams a test suite JSON stanza containing the given test result.
void JsonUnitTestResultPrinter::OutputJsonTestSuiteForTestResult(
<span style = "background-color:#fdd">    ::std::ostream* stream, const TestResult&amp; result) {</span>
  // Output the boilerplate for a new test suite.
<span style = "background-color:#fdd">  *stream &lt;&lt; Indent(4) &lt;&lt; "{\n";
  OutputJsonKey(stream, "testsuite", "name", "NonTestSuiteFailure", Indent(6));
  OutputJsonKey(stream, "testsuite", "tests", 1, Indent(6));
  if (!GTEST_FLAG(list_tests)) {
    OutputJsonKey(stream, "testsuite", "failures", 1, Indent(6));
    OutputJsonKey(stream, "testsuite", "disabled", 0, Indent(6));
    OutputJsonKey(stream, "testsuite", "skipped", 0, Indent(6));
    OutputJsonKey(stream, "testsuite", "errors", 0, Indent(6));
    OutputJsonKey(stream, "testsuite", "time",</span>
                  FormatTimeInMillisAsDuration(result.elapsed_time()),
                  Indent(6));
<span style = "background-color:#fdd">    OutputJsonKey(stream, "testsuite", "timestamp",</span>
                  FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
                  Indent(6));
  }
<span style = "background-color:#fdd">  *stream &lt;&lt; Indent(6) &lt;&lt; "\"testsuite\": [\n";</span>

  // Output the boilerplate for a new test case.
<span style = "background-color:#fdd">  *stream &lt;&lt; Indent(8) &lt;&lt; "{\n";
  OutputJsonKey(stream, "testcase", "name", "", Indent(10));
  OutputJsonKey(stream, "testcase", "status", "RUN", Indent(10));
  OutputJsonKey(stream, "testcase", "result", "COMPLETED", Indent(10));
  OutputJsonKey(stream, "testcase", "timestamp",</span>
                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
                Indent(10));
<span style = "background-color:#fdd">  OutputJsonKey(stream, "testcase", "time",</span>
                FormatTimeInMillisAsDuration(result.elapsed_time()),
                Indent(10));
<span style = "background-color:#fdd">  OutputJsonKey(stream, "testcase", "classname", "", Indent(10), false);
  *stream &lt;&lt; TestPropertiesAsJson(result, Indent(10));</span>

  // Output the actual test result.
<span style = "background-color:#fdd">  OutputJsonTestResult(stream, result);</span>

  // Finish the test suite.
<span style = "background-color:#fdd">  *stream &lt;&lt; "\n" &lt;&lt; Indent(6) &lt;&lt; "]\n" &lt;&lt; Indent(4) &lt;&lt; "}";
}</span>

// Prints a JSON representation of a TestInfo object.
void JsonUnitTestResultPrinter::OutputJsonTestInfo(::std::ostream* stream,
                                                   const char* test_suite_name,
<span style = "background-color:#fdd">                                                   const TestInfo&amp; test_info) {
  const TestResult&amp; result = *test_info.result();
  const std::string kTestsuite = "testcase";
  const std::string kIndent = Indent(10);</span>

<span style = "background-color:#fdd">  *stream &lt;&lt; Indent(8) &lt;&lt; "{\n";
  OutputJsonKey(stream, kTestsuite, "name", test_info.name(), kIndent);</span>

<span style = "background-color:#fdd">  if (test_info.value_param() != nullptr) {
    OutputJsonKey(stream, kTestsuite, "value_param", test_info.value_param(),</span>
                  kIndent);
  }
<span style = "background-color:#fdd">  if (test_info.type_param() != nullptr) {
    OutputJsonKey(stream, kTestsuite, "type_param", test_info.type_param(),</span>
                  kIndent);
  }
<span style = "background-color:#fdd">  if (GTEST_FLAG(list_tests)) {
    OutputJsonKey(stream, kTestsuite, "file", test_info.file(), kIndent);
    OutputJsonKey(stream, kTestsuite, "line", test_info.line(), kIndent, false);
    *stream &lt;&lt; "\n" &lt;&lt; Indent(8) &lt;&lt; "}";
    return;</span>
  }

<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuite, "status",</span>
                test_info.should_run() ? "RUN" : "NOTRUN", kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuite, "result",</span>
                test_info.should_run()
                    ? (result.Skipped() ? "SKIPPED" : "COMPLETED")
                    : "SUPPRESSED",
                kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuite, "timestamp",</span>
                FormatEpochTimeInMillisAsRFC3339(result.start_timestamp()),
                kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuite, "time",</span>
                FormatTimeInMillisAsDuration(result.elapsed_time()), kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuite, "classname", test_suite_name, kIndent,</span>
                false);
<span style = "background-color:#fdd">  *stream &lt;&lt; TestPropertiesAsJson(result, kIndent);</span>

<span style = "background-color:#fdd">  OutputJsonTestResult(stream, result);
}</span>

void JsonUnitTestResultPrinter::OutputJsonTestResult(::std::ostream* stream,
<span style = "background-color:#fdd">                                                     const TestResult&amp; result) {
  const std::string kIndent = Indent(10);</span>

<span style = "background-color:#fdd">  int failures = 0;
  for (int i = 0; i &lt; result.total_part_count(); ++i) {
    const TestPartResult&amp; part = result.GetTestPartResult(i);
    if (part.failed()) {
      *stream &lt;&lt; ",\n";
      if (++failures == 1) {
        *stream &lt;&lt; kIndent &lt;&lt; "\"" &lt;&lt; "failures" &lt;&lt; "\": [\n";</span>
      }
<span style = "background-color:#fdd">      const std::string location =</span>
          internal::FormatCompilerIndependentFileLocation(part.file_name(),
                                                          part.line_number());
<span style = "background-color:#fdd">      const std::string message = EscapeJson(location + "\n" + part.message());
      *stream &lt;&lt; kIndent &lt;&lt; "  {\n"</span>
              &lt;&lt; kIndent &lt;&lt; "    \"failure\": \"" &lt;&lt; message &lt;&lt; "\",\n"
              &lt;&lt; kIndent &lt;&lt; "    \"type\": \"\"\n"
              &lt;&lt; kIndent &lt;&lt; "  }";
<span style = "background-color:#fdd">    }
  }</span>

<span style = "background-color:#fdd">  if (failures &gt; 0)
    *stream &lt;&lt; "\n" &lt;&lt; kIndent &lt;&lt; "]";
  *stream &lt;&lt; "\n" &lt;&lt; Indent(8) &lt;&lt; "}";
}</span>

// Prints an JSON representation of a TestSuite object
void JsonUnitTestResultPrinter::PrintJsonTestSuite(
<span style = "background-color:#fdd">    std::ostream* stream, const TestSuite&amp; test_suite) {
  const std::string kTestsuite = "testsuite";
  const std::string kIndent = Indent(6);</span>

<span style = "background-color:#fdd">  *stream &lt;&lt; Indent(4) &lt;&lt; "{\n";
  OutputJsonKey(stream, kTestsuite, "name", test_suite.name(), kIndent);
  OutputJsonKey(stream, kTestsuite, "tests", test_suite.reportable_test_count(),</span>
                kIndent);
<span style = "background-color:#fdd">  if (!GTEST_FLAG(list_tests)) {
    OutputJsonKey(stream, kTestsuite, "failures",</span>
                  test_suite.failed_test_count(), kIndent);
<span style = "background-color:#fdd">    OutputJsonKey(stream, kTestsuite, "disabled",</span>
                  test_suite.reportable_disabled_test_count(), kIndent);
<span style = "background-color:#fdd">    OutputJsonKey(stream, kTestsuite, "errors", 0, kIndent);
    OutputJsonKey(</span>
        stream, kTestsuite, "timestamp",
        FormatEpochTimeInMillisAsRFC3339(test_suite.start_timestamp()),
        kIndent);
<span style = "background-color:#fdd">    OutputJsonKey(stream, kTestsuite, "time",</span>
                  FormatTimeInMillisAsDuration(test_suite.elapsed_time()),
                  kIndent, false);
<span style = "background-color:#fdd">    *stream &lt;&lt; TestPropertiesAsJson(test_suite.ad_hoc_test_result(), kIndent)</span>
            &lt;&lt; ",\n";
  }

<span style = "background-color:#fdd">  *stream &lt;&lt; kIndent &lt;&lt; "\"" &lt;&lt; kTestsuite &lt;&lt; "\": [\n";</span>

<span style = "background-color:#fdd">  bool comma = false;
  for (int i = 0; i &lt; test_suite.total_test_count(); ++i) {
    if (test_suite.GetTestInfo(i)-&gt;is_reportable()) {
      if (comma) {
        *stream &lt;&lt; ",\n";
      } else {
        comma = true;</span>
      }
<span style = "background-color:#fdd">      OutputJsonTestInfo(stream, test_suite.name(), *test_suite.GetTestInfo(i));</span>
    }
<span style = "background-color:#fdd">  }
  *stream &lt;&lt; "\n" &lt;&lt; kIndent &lt;&lt; "]\n" &lt;&lt; Indent(4) &lt;&lt; "}";
}</span>

// Prints a JSON summary of unit_test to output stream out.
void JsonUnitTestResultPrinter::PrintJsonUnitTest(std::ostream* stream,
<span style = "background-color:#fdd">                                                  const UnitTest&amp; unit_test) {
  const std::string kTestsuites = "testsuites";
  const std::string kIndent = Indent(2);
  *stream &lt;&lt; "{\n";</span>

<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "tests", unit_test.reportable_test_count(),</span>
                kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "failures", unit_test.failed_test_count(),</span>
                kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "disabled",</span>
                unit_test.reportable_disabled_test_count(), kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "errors", 0, kIndent);
  if (GTEST_FLAG(shuffle)) {
    OutputJsonKey(stream, kTestsuites, "random_seed", unit_test.random_seed(),</span>
                  kIndent);
  }
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "timestamp",</span>
                FormatEpochTimeInMillisAsRFC3339(unit_test.start_timestamp()),
                kIndent);
<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "time",</span>
                FormatTimeInMillisAsDuration(unit_test.elapsed_time()), kIndent,
                false);

<span style = "background-color:#fdd">  *stream &lt;&lt; TestPropertiesAsJson(unit_test.ad_hoc_test_result(), kIndent)</span>
          &lt;&lt; ",\n";

<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent);
  *stream &lt;&lt; kIndent &lt;&lt; "\"" &lt;&lt; kTestsuites &lt;&lt; "\": [\n";</span>

<span style = "background-color:#fdd">  bool comma = false;
  for (int i = 0; i &lt; unit_test.total_test_suite_count(); ++i) {
    if (unit_test.GetTestSuite(i)-&gt;reportable_test_count() &gt; 0) {
      if (comma) {
        *stream &lt;&lt; ",\n";
      } else {
        comma = true;</span>
      }
<span style = "background-color:#fdd">      PrintJsonTestSuite(stream, *unit_test.GetTestSuite(i));</span>
    }
<span style = "background-color:#fdd">  }</span>

  // If there was a test failure outside of one of the test suites (like in a
  // test environment) include that in the output.
<span style = "background-color:#fdd">  if (unit_test.ad_hoc_test_result().Failed()) {
    OutputJsonTestSuiteForTestResult(stream, unit_test.ad_hoc_test_result());</span>
  }

<span style = "background-color:#fdd">  *stream &lt;&lt; "\n" &lt;&lt; kIndent &lt;&lt; "]\n" &lt;&lt; "}\n";
}</span>

void JsonUnitTestResultPrinter::PrintJsonTestList(
<span style = "background-color:#fdd">    std::ostream* stream, const std::vector&lt;TestSuite*&gt;&amp; test_suites) {
  const std::string kTestsuites = "testsuites";
  const std::string kIndent = Indent(2);
  *stream &lt;&lt; "{\n";
  int total_tests = 0;
  for (auto test_suite : test_suites) {
    total_tests += test_suite-&gt;total_test_count();
  }
  OutputJsonKey(stream, kTestsuites, "tests", total_tests, kIndent);</span>

<span style = "background-color:#fdd">  OutputJsonKey(stream, kTestsuites, "name", "AllTests", kIndent);
  *stream &lt;&lt; kIndent &lt;&lt; "\"" &lt;&lt; kTestsuites &lt;&lt; "\": [\n";</span>

<span style = "background-color:#fdd">  for (size_t i = 0; i &lt; test_suites.size(); ++i) {
    if (i != 0) {
      *stream &lt;&lt; ",\n";</span>
    }
<span style = "background-color:#fdd">    PrintJsonTestSuite(stream, *test_suites[i]);
  }</span>

<span style = "background-color:#fdd">  *stream &lt;&lt; "\n"</span>
          &lt;&lt; kIndent &lt;&lt; "]\n"
          &lt;&lt; "}\n";
<span style = "background-color:#fdd">}</span>
// Produces a string representing the test properties in a result as
// a JSON dictionary.
std::string JsonUnitTestResultPrinter::TestPropertiesAsJson(
<span style = "background-color:#fdd">    const TestResult&amp; result, const std::string&amp; indent) {
  Message attributes;
  for (int i = 0; i &lt; result.test_property_count(); ++i) {
    const TestProperty&amp; property = result.GetTestProperty(i);
    attributes &lt;&lt; ",\n" &lt;&lt; indent &lt;&lt; "\"" &lt;&lt; property.key() &lt;&lt; "\": "</span>
               &lt;&lt; "\"" &lt;&lt; EscapeJson(property.value()) &lt;&lt; "\"";
<span style = "background-color:#fdd">  }
  return attributes.GetString();
}</span>

// End JsonUnitTestResultPrinter

#if GTEST_CAN_STREAM_RESULTS_

// Checks if str contains '=', '&amp;', '%' or '\n' characters. If yes,
// replaces them by "%xx" where xx is their hexadecimal value. For
// example, replaces "=" with "%3D".  This algorithm is O(strlen(str))
// in both time and space -- important as the input str may contain an
// arbitrarily long test failure message and stack trace.
std::string StreamingListener::UrlEncode(const char* str) {
  std::string result;
  result.reserve(strlen(str) + 1);
  for (char ch = *str; ch != '\0'; ch = *++str) {
    switch (ch) {
      case '%':
      case '=':
      case '&amp;':
      case '\n':
        result.append("%" + String::FormatByte(static_cast&lt;unsigned char&gt;(ch)));
        break;
      default:
        result.push_back(ch);
        break;
    }
  }
  return result;
}

void StreamingListener::SocketWriter::MakeConnection() {
  GTEST_CHECK_(sockfd_ == -1)
      &lt;&lt; "MakeConnection() can't be called when there is already a connection.";

  addrinfo hints;
  memset(&amp;hints, 0, sizeof(hints));
  hints.ai_family = AF_UNSPEC;    // To allow both IPv4 and IPv6 addresses.
  hints.ai_socktype = SOCK_STREAM;
  addrinfo* servinfo = nullptr;

  // Use the getaddrinfo() to get a linked list of IP addresses for
  // the given host name.
  const int error_num = getaddrinfo(
      host_name_.c_str(), port_num_.c_str(), &amp;hints, &amp;servinfo);
  if (error_num != 0) {
    GTEST_LOG_(WARNING) &lt;&lt; "stream_result_to: getaddrinfo() failed: "
                        &lt;&lt; gai_strerror(error_num);
  }

  // Loop through all the results and connect to the first we can.
  for (addrinfo* cur_addr = servinfo; sockfd_ == -1 &amp;&amp; cur_addr != nullptr;
       cur_addr = cur_addr-&gt;ai_next) {
    sockfd_ = socket(
        cur_addr-&gt;ai_family, cur_addr-&gt;ai_socktype, cur_addr-&gt;ai_protocol);
    if (sockfd_ != -1) {
      // Connect the client socket to the server socket.
      if (connect(sockfd_, cur_addr-&gt;ai_addr, cur_addr-&gt;ai_addrlen) == -1) {
        close(sockfd_);
        sockfd_ = -1;
      }
    }
  }

  freeaddrinfo(servinfo);  // all done with this structure

  if (sockfd_ == -1) {
    GTEST_LOG_(WARNING) &lt;&lt; "stream_result_to: failed to connect to "
                        &lt;&lt; host_name_ &lt;&lt; ":" &lt;&lt; port_num_;
  }
}

// End of class Streaming Listener
#endif  // GTEST_CAN_STREAM_RESULTS__

// class OsStackTraceGetter

const char* const OsStackTraceGetterInterface::kElidedFramesMarker =
    "... " GTEST_NAME_ " internal frames ...";

std::string OsStackTraceGetter::CurrentStackTrace(int max_depth, int skip_count)
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {</span>
#if GTEST_HAS_ABSL
  std::string result;

  if (max_depth &lt;= 0) {
    return result;
  }

  max_depth = std::min(max_depth, kMaxStackTraceDepth);

  std::vector&lt;void*&gt; raw_stack(max_depth);
  // Skips the frames requested by the caller, plus this function.
  const int raw_stack_size =
      absl::GetStackTrace(&amp;raw_stack[0], max_depth, skip_count + 1);

  void* caller_frame = nullptr;
  {
    MutexLock lock(&amp;mutex_);
    caller_frame = caller_frame_;
  }

  for (int i = 0; i &lt; raw_stack_size; ++i) {
    if (raw_stack[i] == caller_frame &amp;&amp;
        !GTEST_FLAG(show_internal_stack_frames)) {
      // Add a marker to the trace and stop adding frames.
      absl::StrAppend(&amp;result, kElidedFramesMarker, "\n");
      break;
    }

    char tmp[1024];
    const char* symbol = "(unknown)";
    if (absl::Symbolize(raw_stack[i], tmp, sizeof(tmp))) {
      symbol = tmp;
    }

    char line[1024];
    snprintf(line, sizeof(line), "  %p: %s\n", raw_stack[i], symbol);
    result += line;
  }

  return result;

#else  // !GTEST_HAS_ABSL
  static_cast&lt;void&gt;(max_depth);
  static_cast&lt;void&gt;(skip_count);
<span style = "background-color:#fdd">  return "";</span>
#endif  // GTEST_HAS_ABSL
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#dfd">void OsStackTraceGetter::UponLeavingGTest() GTEST_LOCK_EXCLUDED_(mutex_) {</span>
#if GTEST_HAS_ABSL
  void* caller_frame = nullptr;
  if (absl::GetStackTrace(&amp;caller_frame, 1, 3) &lt;= 0) {
    caller_frame = nullptr;
  }

  MutexLock lock(&amp;mutex_);
  caller_frame_ = caller_frame;
#endif  // GTEST_HAS_ABSL
<span style = "background-color:#dfd">}</span>

// A helper class that creates the premature-exit file in its
// constructor and deletes the file in its destructor.
class ScopedPrematureExitFile {
 public:
  explicit ScopedPrematureExitFile(const char* premature_exit_filepath)
<span style = "background-color:#dfd">      : premature_exit_filepath_(premature_exit_filepath ?
                                 premature_exit_filepath : "") {</span>
    // If a path to the premature-exit file is specified...
<span style = "background-color:#dfd">    if (!premature_exit_filepath_.empty()) {</span>
      // create the file with a single "0" character in it.  I/O
      // errors are ignored as there's nothing better we can do and we
      // don't want to fail the test because of this.
<span style = "background-color:#fdd">      FILE* pfile = posix::FOpen(premature_exit_filepath, "w");
      fwrite("0", 1, 1, pfile);
      fclose(pfile);</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  ~ScopedPrematureExitFile() {</span>
#if !defined GTEST_OS_ESP8266
<span style = "background-color:#dfd">    if (!premature_exit_filepath_.empty()) {</span>
<span style = "background-color:#fdd">      int retval = remove(premature_exit_filepath_.c_str());
      if (retval) {
        GTEST_LOG_(ERROR) &lt;&lt; "Failed to remove premature exit filepath \""</span>
                          &lt;&lt; premature_exit_filepath_ &lt;&lt; "\" with error "
                          &lt;&lt; retval;
      }
    }
#endif
<span style = "background-color:#dfd">  }</span>

 private:
  const std::string premature_exit_filepath_;

  GTEST_DISALLOW_COPY_AND_ASSIGN_(ScopedPrematureExitFile);
};

}  // namespace internal

// class TestEventListeners

TestEventListeners::TestEventListeners()
<span style = "background-color:#dfd">    : repeater_(new internal::TestEventRepeater()),
      default_result_printer_(nullptr),
      default_xml_generator_(nullptr) {}</span>

<span style = "background-color:#dfd">TestEventListeners::~TestEventListeners() { delete repeater_; }</span>

// Returns the standard listener responsible for the default console
// output.  Can be removed from the listeners list to shut down default
// console output.  Note that removing this object from the listener list
// with Release transfers its ownership to the user.
<span style = "background-color:#dfd">void TestEventListeners::Append(TestEventListener* listener) {
  repeater_-&gt;Append(listener);
}</span>

// Removes the given event listener from the list and returns it.  It then
// becomes the caller's responsibility to delete the listener. Returns
// NULL if the listener is not found in the list.
<span style = "background-color:#dfd">TestEventListener* TestEventListeners::Release(TestEventListener* listener) {
  if (listener == default_result_printer_)
    default_result_printer_ = nullptr;</span>
<span style = "background-color:#fdd">  else if (listener == default_xml_generator_)
    default_xml_generator_ = nullptr;</span>
<span style = "background-color:#dfd">  return repeater_-&gt;Release(listener);
}</span>

// Returns repeater that broadcasts the TestEventListener events to all
// subscribers.
<span style = "background-color:#dfd">TestEventListener* TestEventListeners::repeater() { return repeater_; }</span>

// Sets the default_result_printer attribute to the provided listener.
// The listener is also added to the listener list and previous
// default_result_printer is removed from it and deleted. The listener can
// also be NULL in which case it will not be added to the list. Does
// nothing if the previous and the current listener objects are the same.
<span style = "background-color:#dfd">void TestEventListeners::SetDefaultResultPrinter(TestEventListener* listener) {
  if (default_result_printer_ != listener) {</span>
    // It is an error to pass this method a listener that is already in the
    // list.
<span style = "background-color:#dfd">    delete Release(default_result_printer_);
    default_result_printer_ = listener;
    if (listener != nullptr) Append(listener);</span>
  }
<span style = "background-color:#dfd">}</span>

// Sets the default_xml_generator attribute to the provided listener.  The
// listener is also added to the listener list and previous
// default_xml_generator is removed from it and deleted. The listener can
// also be NULL in which case it will not be added to the list. Does
// nothing if the previous and the current listener objects are the same.
<span style = "background-color:#fdd">void TestEventListeners::SetDefaultXmlGenerator(TestEventListener* listener) {
  if (default_xml_generator_ != listener) {</span>
    // It is an error to pass this method a listener that is already in the
    // list.
<span style = "background-color:#fdd">    delete Release(default_xml_generator_);
    default_xml_generator_ = listener;
    if (listener != nullptr) Append(listener);</span>
  }
<span style = "background-color:#fdd">}</span>

// Controls whether events will be forwarded by the repeater to the
// listeners in the list.
<span style = "background-color:#fdd">bool TestEventListeners::EventForwardingEnabled() const {
  return repeater_-&gt;forwarding_enabled();
}</span>

<span style = "background-color:#fdd">void TestEventListeners::SuppressEventForwarding() {
  repeater_-&gt;set_forwarding_enabled(false);
}</span>

// class UnitTest

// Gets the singleton UnitTest object.  The first time this method is
// called, a UnitTest object is constructed and returned.  Consecutive
// calls will return the same object.
//
// We don't protect this under mutex_ as a user is not supposed to
// call this before main() starts, from which point on the return
// value will never change.
<span style = "background-color:#dfd">UnitTest* UnitTest::GetInstance() {</span>
  // CodeGear C++Builder insists on a public destructor for the
  // default implementation.  Use this implementation to keep good OO
  // design with private destructor.

#if defined(__BORLANDC__)
  static UnitTest* const instance = new UnitTest;
  return instance;
#else
<span style = "background-color:#dfd">  static UnitTest instance;
  return &amp;instance;</span>
#endif  // defined(__BORLANDC__)
<span style = "background-color:#dfd">}</span>

// Gets the number of successful test suites.
<span style = "background-color:#fdd">int UnitTest::successful_test_suite_count() const {
  return impl()-&gt;successful_test_suite_count();
}</span>

// Gets the number of failed test suites.
<span style = "background-color:#fdd">int UnitTest::failed_test_suite_count() const {
  return impl()-&gt;failed_test_suite_count();
}</span>

// Gets the number of all test suites.
<span style = "background-color:#fdd">int UnitTest::total_test_suite_count() const {
  return impl()-&gt;total_test_suite_count();
}</span>

// Gets the number of all test suites that contain at least one test
// that should run.
<span style = "background-color:#dfd">int UnitTest::test_suite_to_run_count() const {
  return impl()-&gt;test_suite_to_run_count();
}</span>

//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">int UnitTest::successful_test_case_count() const {
  return impl()-&gt;successful_test_suite_count();
}
int UnitTest::failed_test_case_count() const {
  return impl()-&gt;failed_test_suite_count();
}
int UnitTest::total_test_case_count() const {
  return impl()-&gt;total_test_suite_count();
}
int UnitTest::test_case_to_run_count() const {
  return impl()-&gt;test_suite_to_run_count();
}</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

// Gets the number of successful tests.
<span style = "background-color:#dfd">int UnitTest::successful_test_count() const {
  return impl()-&gt;successful_test_count();
}</span>

// Gets the number of skipped tests.
<span style = "background-color:#dfd">int UnitTest::skipped_test_count() const {
  return impl()-&gt;skipped_test_count();
}</span>

// Gets the number of failed tests.
<span style = "background-color:#fdd">int UnitTest::failed_test_count() const { return impl()-&gt;failed_test_count(); }</span>

// Gets the number of disabled tests that will be reported in the XML report.
<span style = "background-color:#dfd">int UnitTest::reportable_disabled_test_count() const {
  return impl()-&gt;reportable_disabled_test_count();
}</span>

// Gets the number of disabled tests.
<span style = "background-color:#fdd">int UnitTest::disabled_test_count() const {
  return impl()-&gt;disabled_test_count();
}</span>

// Gets the number of tests to be printed in the XML report.
<span style = "background-color:#fdd">int UnitTest::reportable_test_count() const {
  return impl()-&gt;reportable_test_count();
}</span>

// Gets the number of all tests.
<span style = "background-color:#fdd">int UnitTest::total_test_count() const { return impl()-&gt;total_test_count(); }</span>

// Gets the number of tests that should run.
<span style = "background-color:#dfd">int UnitTest::test_to_run_count() const { return impl()-&gt;test_to_run_count(); }</span>

// Gets the time of the test program start, in ms from the start of the
// UNIX epoch.
<span style = "background-color:#fdd">internal::TimeInMillis UnitTest::start_timestamp() const {
    return impl()-&gt;start_timestamp();
}</span>

// Gets the elapsed time, in milliseconds.
<span style = "background-color:#dfd">internal::TimeInMillis UnitTest::elapsed_time() const {
  return impl()-&gt;elapsed_time();
}</span>

// Returns true if and only if the unit test passed (i.e. all test suites
// passed).
<span style = "background-color:#dfd">bool UnitTest::Passed() const { return impl()-&gt;Passed(); }</span>

// Returns true if and only if the unit test failed (i.e. some test suite
// failed or something outside of all tests failed).
<span style = "background-color:#fdd">bool UnitTest::Failed() const { return impl()-&gt;Failed(); }</span>

// Gets the i-th test suite among all the test suites. i can range from 0 to
// total_test_suite_count() - 1. If i is not in that range, returns NULL.
<span style = "background-color:#fdd">const TestSuite* UnitTest::GetTestSuite(int i) const {
  return impl()-&gt;GetTestSuite(i);
}</span>

//  Legacy API is deprecated but still available
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
<span style = "background-color:#fdd">const TestCase* UnitTest::GetTestCase(int i) const {
  return impl()-&gt;GetTestCase(i);
}</span>
#endif  //  GTEST_REMOVE_LEGACY_TEST_CASEAPI_

// Returns the TestResult containing information on test failures and
// properties logged outside of individual test suites.
<span style = "background-color:#fdd">const TestResult&amp; UnitTest::ad_hoc_test_result() const {
  return *impl()-&gt;ad_hoc_test_result();
}</span>

// Gets the i-th test suite among all the test suites. i can range from 0 to
// total_test_suite_count() - 1. If i is not in that range, returns NULL.
<span style = "background-color:#fdd">TestSuite* UnitTest::GetMutableTestSuite(int i) {
  return impl()-&gt;GetMutableSuiteCase(i);
}</span>

// Returns the list of event listeners that can be used to track events
// inside Google Test.
<span style = "background-color:#dfd">TestEventListeners&amp; UnitTest::listeners() {
  return *impl()-&gt;listeners();
}</span>

// Registers and returns a global test environment.  When a test
// program is run, all global test environments will be set-up in the
// order they were registered.  After all tests in the program have
// finished, all global test environments will be torn-down in the
// *reverse* order they were registered.
//
// The UnitTest object takes ownership of the given environment.
//
// We don't protect this under mutex_, as we only support calling it
// from the main thread.
<span style = "background-color:#fdd">Environment* UnitTest::AddEnvironment(Environment* env) {
  if (env == nullptr) {
    return nullptr;</span>
  }

<span style = "background-color:#fdd">  impl_-&gt;environments().push_back(env);
  return env;
}</span>

// Adds a TestPartResult to the current TestResult object.  All Google Test
// assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc) eventually call
// this to report their results.  The user code should use the
// assertion macros instead of calling this directly.
void UnitTest::AddTestPartResult(
    TestPartResult::Type result_type,
    const char* file_name,
    int line_number,
    const std::string&amp; message,
<span style = "background-color:#fdd">    const std::string&amp; os_stack_trace) GTEST_LOCK_EXCLUDED_(mutex_) {
  Message msg;
  msg &lt;&lt; message;</span>

<span style = "background-color:#fdd">  internal::MutexLock lock(&amp;mutex_);
  if (impl_-&gt;gtest_trace_stack().size() &gt; 0) {
    msg &lt;&lt; "\n" &lt;&lt; GTEST_NAME_ &lt;&lt; " trace:";</span>

<span style = "background-color:#fdd">    for (size_t i = impl_-&gt;gtest_trace_stack().size(); i &gt; 0; --i) {
      const internal::TraceInfo&amp; trace = impl_-&gt;gtest_trace_stack()[i - 1];
      msg &lt;&lt; "\n" &lt;&lt; internal::FormatFileLocation(trace.file, trace.line)</span>
          &lt;&lt; " " &lt;&lt; trace.message;
<span style = "background-color:#fdd">    }</span>
  }

<span style = "background-color:#fdd">  if (os_stack_trace.c_str() != nullptr &amp;&amp; !os_stack_trace.empty()) {
    msg &lt;&lt; internal::kStackTraceMarker &lt;&lt; os_stack_trace;</span>
  }

<span style = "background-color:#fdd">  const TestPartResult result = TestPartResult(</span>
      result_type, file_name, line_number, msg.GetString().c_str());
<span style = "background-color:#fdd">  impl_-&gt;GetTestPartResultReporterForCurrentThread()-&gt;</span>
      ReportTestPartResult(result);

<span style = "background-color:#fdd">  if (result_type != TestPartResult::kSuccess &amp;&amp;</span>
      result_type != TestPartResult::kSkip) {
    // gtest_break_on_failure takes precedence over
    // gtest_throw_on_failure.  This allows a user to set the latter
    // in the code (perhaps in order to use Google Test assertions
    // with another testing framework) and specify the former on the
    // command line for debugging.
<span style = "background-color:#fdd">    if (GTEST_FLAG(break_on_failure)) {</span>
#if GTEST_OS_WINDOWS &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT
      // Using DebugBreak on Windows allows gtest to still break into a debugger
      // when a failure happens and both the --gtest_break_on_failure and
      // the --gtest_catch_exceptions flags are specified.
<span style = "background-color:#fdd">      DebugBreak();</span>
#elif (!defined(__native_client__)) &amp;&amp;            \
    ((defined(__clang__) || defined(__GNUC__)) &amp;&amp; \
     (defined(__x86_64__) || defined(__i386__)))
      // with clang/gcc we can achieve the same effect on x86 by invoking int3
      asm("int3");
#else
      // Dereference nullptr through a volatile pointer to prevent the compiler
      // from removing. We use this rather than abort() or __builtin_trap() for
      // portability: some debuggers don't correctly trap abort().
      *static_cast&lt;volatile int*&gt;(nullptr) = 1;
#endif  // GTEST_OS_WINDOWS
<span style = "background-color:#fdd">    } else if (GTEST_FLAG(throw_on_failure)) {</span>
#if GTEST_HAS_EXCEPTIONS
<span style = "background-color:#fdd">      throw internal::GoogleTestFailureException(result);</span>
#else
      // We cannot call abort() as it generates a pop-up in debug mode
      // that cannot be suppressed in VC 7.1 or below.
      exit(1);
#endif
    }
  }
<span style = "background-color:#fdd">}</span>

// Adds a TestProperty to the current TestResult object when invoked from
// inside a test, to current TestSuite's ad_hoc_test_result_ when invoked
// from SetUpTestSuite or TearDownTestSuite, or to the global property set
// when invoked elsewhere.  If the result already contains a property with
// the same key, the value will be updated.
void UnitTest::RecordProperty(const std::string&amp; key,
<span style = "background-color:#fdd">                              const std::string&amp; value) {
  impl_-&gt;RecordProperty(TestProperty(key, value));
}</span>

// Runs all tests in this UnitTest object and prints the result.
// Returns 0 if successful, or 1 otherwise.
//
// We don't protect this under mutex_, as we only support calling it
// from the main thread.
<span style = "background-color:#dfd">int UnitTest::Run() {
  const bool in_death_test_child_process =</span>
      internal::GTEST_FLAG(internal_run_death_test).length() &gt; 0;

  // Google Test implements this protocol for catching that a test
  // program exits before returning control to Google Test:
  //
  //   1. Upon start, Google Test creates a file whose absolute path
  //      is specified by the environment variable
  //      TEST_PREMATURE_EXIT_FILE.
  //   2. When Google Test has finished its work, it deletes the file.
  //
  // This allows a test runner to set TEST_PREMATURE_EXIT_FILE before
  // running a Google-Test-based test program and check the existence
  // of the file at the end of the test execution to see if it has
  // exited prematurely.

  // If we are in the child process of a death test, don't
  // create/delete the premature exit file, as doing so is unnecessary
  // and will confuse the parent process.  Otherwise, create/delete
  // the file upon entering/leaving this function.  If the program
  // somehow exits before this function has a chance to return, the
  // premature-exit file will be left undeleted, causing a test runner
  // that understands the premature-exit-file protocol to report the
  // test as having failed.
<span style = "background-color:#dfd">  const internal::ScopedPrematureExitFile premature_exit_file(</span>
      in_death_test_child_process
          ? nullptr
          : internal::posix::GetEnv("TEST_PREMATURE_EXIT_FILE"));

  // Captures the value of GTEST_FLAG(catch_exceptions).  This value will be
  // used for the duration of the program.
<span style = "background-color:#dfd">  impl()-&gt;set_catch_exceptions(GTEST_FLAG(catch_exceptions));</span>

#if GTEST_OS_WINDOWS
  // Either the user wants Google Test to catch exceptions thrown by the
  // tests or this is executing in the context of death test child
  // process. In either case the user does not want to see pop-up dialogs
  // about crashes - they are expected.
<span style = "background-color:#dfd">  if (impl()-&gt;catch_exceptions() || in_death_test_child_process) {</span>
# if !GTEST_OS_WINDOWS_MOBILE &amp;&amp; !GTEST_OS_WINDOWS_PHONE &amp;&amp; !GTEST_OS_WINDOWS_RT
    // SetErrorMode doesn't exist on CE.
<span style = "background-color:#dfd">    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |</span>
                 SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
# endif  // !GTEST_OS_WINDOWS_MOBILE

# if (defined(_MSC_VER) || GTEST_OS_WINDOWS_MINGW) &amp;&amp; !GTEST_OS_WINDOWS_MOBILE
    // Death test children can be terminated with _abort().  On Windows,
    // _abort() can show a dialog with a warning message.  This forces the
    // abort message to go to stderr instead.
<span style = "background-color:#dfd">    _set_error_mode(_OUT_TO_STDERR);</span>
# endif

# if defined(_MSC_VER) &amp;&amp; !GTEST_OS_WINDOWS_MOBILE
    // In the debug version, Visual Studio pops up a separate dialog
    // offering a choice to debug the aborted program. We need to suppress
    // this dialog or it will pop up for every EXPECT/ASSERT_DEATH statement
    // executed. Google Test will notify the user of any unexpected
    // failure via stderr.
<span style = "background-color:#dfd">    if (!GTEST_FLAG(break_on_failure))
      _set_abort_behavior(</span>
          0x0,                                    // Clear the following flags:
          _WRITE_ABORT_MSG | _CALL_REPORTFAULT);  // pop-up window, core dump.

    // In debug mode, the Windows CRT can crash with an assertion over invalid
    // input (e.g. passing an invalid file descriptor).  The default handling
    // for these assertions is to pop up a dialog and wait for user input.
    // Instead ask the CRT to dump such assertions to stderr non-interactively.
<span style = "background-color:#dfd">    if (!IsDebuggerPresent()) {</span>
<span style = "background-color:#fdd">      (void)_CrtSetReportMode(_CRT_ASSERT,</span>
                              _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
<span style = "background-color:#fdd">      (void)_CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);</span>
    }
# endif
  }
#endif  // GTEST_OS_WINDOWS

<span style = "background-color:#dfd">  return internal::HandleExceptionsInMethodIfSupported(</span>
      impl(),
      &amp;internal::UnitTestImpl::RunAllTests,
      "auxiliary test code (environments or event listeners)") ? 0 : 1;
<span style = "background-color:#dfd">}</span>

// Returns the working directory when the first TEST() or TEST_F() was
// executed.
<span style = "background-color:#fdd">const char* UnitTest::original_working_dir() const {
  return impl_-&gt;original_working_dir_.c_str();
}</span>

// Returns the TestSuite object for the test that's currently running,
// or NULL if no test is running.
const TestSuite* UnitTest::current_test_suite() const
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {
  internal::MutexLock lock(&amp;mutex_);
  return impl_-&gt;current_test_suite();
}</span>

// Legacy API is still available but deprecated
#ifndef GTEST_REMOVE_LEGACY_TEST_CASEAPI_
const TestCase* UnitTest::current_test_case() const
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {
  internal::MutexLock lock(&amp;mutex_);
  return impl_-&gt;current_test_suite();
}</span>
#endif

// Returns the TestInfo object for the test that's currently running,
// or NULL if no test is running.
const TestInfo* UnitTest::current_test_info() const
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {
  internal::MutexLock lock(&amp;mutex_);
  return impl_-&gt;current_test_info();
}</span>

// Returns the random seed used at the start of the current test run.
<span style = "background-color:#fdd">int UnitTest::random_seed() const { return impl_-&gt;random_seed(); }</span>

// Returns ParameterizedTestSuiteRegistry object used to keep track of
// value-parameterized tests and instantiate and register them.
internal::ParameterizedTestSuiteRegistry&amp;
<span style = "background-color:#fdd">UnitTest::parameterized_test_registry() GTEST_LOCK_EXCLUDED_(mutex_) {
  return impl_-&gt;parameterized_test_registry();
}</span>

// Creates an empty UnitTest.
<span style = "background-color:#dfd">UnitTest::UnitTest() {
  impl_ = new internal::UnitTestImpl(this);
}</span>

// Destructor of UnitTest.
<span style = "background-color:#dfd">UnitTest::~UnitTest() {
  delete impl_;
}</span>

// Pushes a trace defined by SCOPED_TRACE() on to the per-thread
// Google Test trace stack.
void UnitTest::PushGTestTrace(const internal::TraceInfo&amp; trace)
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {
  internal::MutexLock lock(&amp;mutex_);
  impl_-&gt;gtest_trace_stack().push_back(trace);
}</span>

// Pops a trace from the per-thread Google Test trace stack.
void UnitTest::PopGTestTrace()
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(mutex_) {
  internal::MutexLock lock(&amp;mutex_);
  impl_-&gt;gtest_trace_stack().pop_back();
}</span>

namespace internal {

UnitTestImpl::UnitTestImpl(UnitTest* parent)
<span style = "background-color:#dfd">    : parent_(parent),</span>
      GTEST_DISABLE_MSC_WARNINGS_PUSH_(4355 /* using this in initializer */)
<span style = "background-color:#dfd">          default_global_test_part_result_reporter_(this),
      default_per_thread_test_part_result_reporter_(this),
      GTEST_DISABLE_MSC_WARNINGS_POP_() global_test_part_result_repoter_(</span>
          &amp;default_global_test_part_result_reporter_),
<span style = "background-color:#dfd">      per_thread_test_part_result_reporter_(</span>
          &amp;default_per_thread_test_part_result_reporter_),
<span style = "background-color:#dfd">      parameterized_test_registry_(),
      parameterized_tests_registered_(false),
      last_death_test_suite_(-1),
      current_test_suite_(nullptr),
      current_test_info_(nullptr),
      ad_hoc_test_result_(),
      os_stack_trace_getter_(nullptr),
      post_flag_parse_init_performed_(false),
      random_seed_(0),  // Will be overridden by the flag before first use.
      random_(0),       // Will be reseeded before first use.
      start_timestamp_(0),
      elapsed_time_(0),</span>
#if GTEST_HAS_DEATH_TEST
<span style = "background-color:#dfd">      death_test_factory_(new DefaultDeathTestFactory),</span>
#endif
      // Will be overridden by the flag before first use.
<span style = "background-color:#dfd">      catch_exceptions_(false) {
  listeners()-&gt;SetDefaultResultPrinter(new PrettyUnitTestResultPrinter);
}</span>

<span style = "background-color:#dfd">UnitTestImpl::~UnitTestImpl() {</span>
  // Deletes every TestSuite.
<span style = "background-color:#dfd">  ForEach(test_suites_, internal::Delete&lt;TestSuite&gt;);</span>

  // Deletes every Environment.
<span style = "background-color:#dfd">  ForEach(environments_, internal::Delete&lt;Environment&gt;);</span>

<span style = "background-color:#dfd">  delete os_stack_trace_getter_;
}</span>

// Adds a TestProperty to the current TestResult object when invoked in a
// context of a test, to current test suite's ad_hoc_test_result when invoke
// from SetUpTestSuite/TearDownTestSuite, or to the global property set
// otherwise.  If the result already contains a property with the same key,
// the value will be updated.
<span style = "background-color:#fdd">void UnitTestImpl::RecordProperty(const TestProperty&amp; test_property) {
  std::string xml_element;</span>
  TestResult* test_result;  // TestResult appropriate for property recording.

<span style = "background-color:#fdd">  if (current_test_info_ != nullptr) {
    xml_element = "testcase";
    test_result = &amp;(current_test_info_-&gt;result_);
  } else if (current_test_suite_ != nullptr) {
    xml_element = "testsuite";
    test_result = &amp;(current_test_suite_-&gt;ad_hoc_test_result_);
  } else {
    xml_element = "testsuites";
    test_result = &amp;ad_hoc_test_result_;</span>
  }
<span style = "background-color:#fdd">  test_result-&gt;RecordProperty(xml_element, test_property);
}</span>

#if GTEST_HAS_DEATH_TEST
// Disables event forwarding if the control is currently in a death test
// subprocess. Must not be called before InitGoogleTest.
<span style = "background-color:#dfd">void UnitTestImpl::SuppressTestEventsIfInSubprocess() {
  if (internal_run_death_test_flag_.get() != nullptr)</span>
<span style = "background-color:#fdd">    listeners()-&gt;SuppressEventForwarding();</span>
<span style = "background-color:#dfd">}</span>
#endif  // GTEST_HAS_DEATH_TEST

// Initializes event listeners performing XML output as specified by
// UnitTestOptions. Must not be called before InitGoogleTest.
<span style = "background-color:#dfd">void UnitTestImpl::ConfigureXmlOutput() {
  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();
  if (output_format == "xml") {</span>
<span style = "background-color:#fdd">    listeners()-&gt;SetDefaultXmlGenerator(new XmlUnitTestResultPrinter(</span>
        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
<span style = "background-color:#fdd">  } else if (output_format == "json") {
    listeners()-&gt;SetDefaultXmlGenerator(new JsonUnitTestResultPrinter(</span>
        UnitTestOptions::GetAbsolutePathToOutputFile().c_str()));
<span style = "background-color:#fdd">  } else if (output_format != "") {
    GTEST_LOG_(WARNING) &lt;&lt; "WARNING: unrecognized output format \""</span>
                        &lt;&lt; output_format &lt;&lt; "\" ignored.";
  }
<span style = "background-color:#dfd">}</span>

#if GTEST_CAN_STREAM_RESULTS_
// Initializes event listeners for streaming test results in string form.
// Must not be called before InitGoogleTest.
void UnitTestImpl::ConfigureStreamingOutput() {
  const std::string&amp; target = GTEST_FLAG(stream_result_to);
  if (!target.empty()) {
    const size_t pos = target.find(':');
    if (pos != std::string::npos) {
      listeners()-&gt;Append(new StreamingListener(target.substr(0, pos),
                                                target.substr(pos+1)));
    } else {
      GTEST_LOG_(WARNING) &lt;&lt; "unrecognized streaming target \"" &lt;&lt; target
                          &lt;&lt; "\" ignored.";
    }
  }
}
#endif  // GTEST_CAN_STREAM_RESULTS_

// Performs initialization dependent upon flag values obtained in
// ParseGoogleTestFlagsOnly.  Is called from InitGoogleTest after the call to
// ParseGoogleTestFlagsOnly.  In case a user neglects to call InitGoogleTest
// this function is also called from RunAllTests.  Since this function can be
// called more than once, it has to be idempotent.
<span style = "background-color:#dfd">void UnitTestImpl::PostFlagParsingInit() {</span>
  // Ensures that this function does not execute more than once.
<span style = "background-color:#dfd">  if (!post_flag_parse_init_performed_) {
    post_flag_parse_init_performed_ = true;</span>

#if defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)
    // Register to send notifications about key process state changes.
    listeners()-&gt;Append(new GTEST_CUSTOM_TEST_EVENT_LISTENER_());
#endif  // defined(GTEST_CUSTOM_TEST_EVENT_LISTENER_)

#if GTEST_HAS_DEATH_TEST
<span style = "background-color:#dfd">    InitDeathTestSubprocessControlInfo();
    SuppressTestEventsIfInSubprocess();</span>
#endif  // GTEST_HAS_DEATH_TEST

    // Registers parameterized tests. This makes parameterized tests
    // available to the UnitTest reflection API without running
    // RUN_ALL_TESTS.
<span style = "background-color:#dfd">    RegisterParameterizedTests();</span>

    // Configures listeners for XML output. This makes it possible for users
    // to shut down the default XML output before invoking RUN_ALL_TESTS.
<span style = "background-color:#dfd">    ConfigureXmlOutput();</span>

<span style = "background-color:#dfd">    if (GTEST_FLAG(brief)) {</span>
<span style = "background-color:#fdd">      listeners()-&gt;SetDefaultResultPrinter(new BriefUnitTestResultPrinter);</span>
    }

#if GTEST_CAN_STREAM_RESULTS_
    // Configures listeners for streaming test results to the specified server.
    ConfigureStreamingOutput();
#endif  // GTEST_CAN_STREAM_RESULTS_

#if GTEST_HAS_ABSL
    if (GTEST_FLAG(install_failure_signal_handler)) {
      absl::FailureSignalHandlerOptions options;
      absl::InstallFailureSignalHandler(options);
    }
#endif  // GTEST_HAS_ABSL
  }
<span style = "background-color:#dfd">}</span>

// A predicate that checks the name of a TestSuite against a known
// value.
//
// This is used for implementation of the UnitTest class only.  We put
// it in the anonymous namespace to prevent polluting the outer
// namespace.
//
// TestSuiteNameIs is copyable.
class TestSuiteNameIs {
 public:
  // Constructor.
<span style = "background-color:#dfd">  explicit TestSuiteNameIs(const std::string&amp; name) : name_(name) {}</span>

  // Returns true if and only if the name of test_suite matches name_.
<span style = "background-color:#dfd">  bool operator()(const TestSuite* test_suite) const {
    return test_suite != nullptr &amp;&amp;</span>
           strcmp(test_suite-&gt;name(), name_.c_str()) == 0;
<span style = "background-color:#dfd">  }</span>

 private:
  std::string name_;
};

// Finds and returns a TestSuite with the given name.  If one doesn't
// exist, creates one and returns it.  It's the CALLER'S
// RESPONSIBILITY to ensure that this function is only called WHEN THE
// TESTS ARE NOT SHUFFLED.
//
// Arguments:
//
//   test_suite_name: name of the test suite
//   type_param:      the name of the test suite's type parameter, or NULL if
//                    this is not a typed or a type-parameterized test suite.
//   set_up_tc:       pointer to the function that sets up the test suite
//   tear_down_tc:    pointer to the function that tears down the test suite
TestSuite* UnitTestImpl::GetTestSuite(
    const char* test_suite_name, const char* type_param,
    internal::SetUpTestSuiteFunc set_up_tc,
<span style = "background-color:#dfd">    internal::TearDownTestSuiteFunc tear_down_tc) {</span>
  // Can we find a TestSuite with the given name?
<span style = "background-color:#dfd">  const auto test_suite =</span>
      std::find_if(test_suites_.rbegin(), test_suites_.rend(),
                   TestSuiteNameIs(test_suite_name));

<span style = "background-color:#dfd">  if (test_suite != test_suites_.rend()) return *test_suite;</span>

  // No.  Let's create one.
<span style = "background-color:#dfd">  auto* const new_test_suite =</span>
      new TestSuite(test_suite_name, type_param, set_up_tc, tear_down_tc);

  // Is this a death test suite?
<span style = "background-color:#dfd">  if (internal::UnitTestOptions::MatchesFilter(test_suite_name,</span>
                                               kDeathTestSuiteFilter)) {
    // Yes.  Inserts the test suite after the last death test suite
    // defined so far.  This only works when the test suites haven't
    // been shuffled.  Otherwise we may end up running a death test
    // after a non-death test.
<span style = "background-color:#fdd">    ++last_death_test_suite_;
    test_suites_.insert(test_suites_.begin() + last_death_test_suite_,</span>
                        new_test_suite);
<span style = "background-color:#fdd">  } else {</span>
    // No.  Appends to the end of the list.
<span style = "background-color:#dfd">    test_suites_.push_back(new_test_suite);</span>
  }

<span style = "background-color:#dfd">  test_suite_indices_.push_back(static_cast&lt;int&gt;(test_suite_indices_.size()));
  return new_test_suite;
}</span>

// Helpers for setting up / tearing down the given environment.  They
// are for use in the ForEach() function.
<span style = "background-color:#fdd">static void SetUpEnvironment(Environment* env) { env-&gt;SetUp(); }
static void TearDownEnvironment(Environment* env) { env-&gt;TearDown(); }</span>

// Runs all tests in this UnitTest object, prints the result, and
// returns true if all tests are successful.  If any exception is
// thrown during a test, the test is considered to be failed, but the
// rest of the tests will still be run.
//
// When parameterized tests are enabled, it expands and registers
// parameterized tests first in RegisterParameterizedTests().
// All other functions called from RunAllTests() may safely assume that
// parameterized tests are ready to be counted and run.
<span style = "background-color:#dfd">bool UnitTestImpl::RunAllTests() {</span>
  // True if and only if Google Test is initialized before RUN_ALL_TESTS() is
  // called.
<span style = "background-color:#dfd">  const bool gtest_is_initialized_before_run_all_tests = GTestIsInitialized();</span>

  // Do not run any test if the --help flag was specified.
<span style = "background-color:#dfd">  if (g_help_flag)</span>
<span style = "background-color:#fdd">    return true;</span>

  // Repeats the call to the post-flag parsing initialization in case the
  // user didn't call InitGoogleTest.
<span style = "background-color:#dfd">  PostFlagParsingInit();</span>

  // Even if sharding is not on, test runners may want to use the
  // GTEST_SHARD_STATUS_FILE to query whether the test supports the sharding
  // protocol.
<span style = "background-color:#dfd">  internal::WriteToShardStatusFileIfNeeded();</span>

  // True if and only if we are in a subprocess for running a thread-safe-style
  // death test.
<span style = "background-color:#dfd">  bool in_subprocess_for_death_test = false;</span>

#if GTEST_HAS_DEATH_TEST
<span style = "background-color:#dfd">  in_subprocess_for_death_test =</span>
      (internal_run_death_test_flag_.get() != nullptr);
# if defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
  if (in_subprocess_for_death_test) {
    GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_();
  }
# endif  // defined(GTEST_EXTRA_DEATH_TEST_CHILD_SETUP_)
#endif  // GTEST_HAS_DEATH_TEST

<span style = "background-color:#dfd">  const bool should_shard = ShouldShard(kTestTotalShards, kTestShardIndex,</span>
                                        in_subprocess_for_death_test);

  // Compares the full test names with the filter to decide which
  // tests to run.
<span style = "background-color:#dfd">  const bool has_tests_to_run = FilterTests(should_shard</span>
                                              ? HONOR_SHARDING_PROTOCOL
                                              : IGNORE_SHARDING_PROTOCOL) &gt; 0;

  // Lists the tests and exits if the --gtest_list_tests flag was specified.
<span style = "background-color:#dfd">  if (GTEST_FLAG(list_tests)) {</span>
    // This must be called *after* FilterTests() has been called.
<span style = "background-color:#fdd">    ListTestsMatchingFilter();
    return true;</span>
  }

<span style = "background-color:#dfd">  random_seed_ = GTEST_FLAG(shuffle) ?</span>
      GetRandomSeedFromFlag(GTEST_FLAG(random_seed)) : 0;

  // True if and only if at least one test has failed.
<span style = "background-color:#dfd">  bool failed = false;</span>

<span style = "background-color:#dfd">  TestEventListener* repeater = listeners()-&gt;repeater();</span>

<span style = "background-color:#dfd">  start_timestamp_ = GetTimeInMillis();
  repeater-&gt;OnTestProgramStart(*parent_);</span>

  // How many times to repeat the tests?  We don't want to repeat them
  // when we are inside the subprocess of a death test.
<span style = "background-color:#dfd">  const int repeat = in_subprocess_for_death_test ? 1 : GTEST_FLAG(repeat);</span>
  // Repeats forever if the repeat count is negative.
<span style = "background-color:#dfd">  const bool gtest_repeat_forever = repeat &lt; 0;
  for (int i = 0; gtest_repeat_forever || i != repeat; i++) {</span>
    // We want to preserve failures generated by ad-hoc test
    // assertions executed before RUN_ALL_TESTS().
<span style = "background-color:#dfd">    ClearNonAdHocTestResult();</span>

<span style = "background-color:#dfd">    Timer timer;</span>

    // Shuffles test suites and tests if requested.
<span style = "background-color:#dfd">    if (has_tests_to_run &amp;&amp; GTEST_FLAG(shuffle)) {</span>
<span style = "background-color:#fdd">      random()-&gt;Reseed(static_cast&lt;uint32_t&gt;(random_seed_));</span>
      // This should be done before calling OnTestIterationStart(),
      // such that a test event listener can see the actual test order
      // in the event.
<span style = "background-color:#fdd">      ShuffleTests();</span>
    }

    // Tells the unit test event listeners that the tests are about to start.
<span style = "background-color:#dfd">    repeater-&gt;OnTestIterationStart(*parent_, i);</span>

    // Runs each test suite if there is at least one test to run.
<span style = "background-color:#dfd">    if (has_tests_to_run) {</span>
      // Sets up all environments beforehand.
<span style = "background-color:#dfd">      repeater-&gt;OnEnvironmentsSetUpStart(*parent_);
      ForEach(environments_, SetUpEnvironment);
      repeater-&gt;OnEnvironmentsSetUpEnd(*parent_);</span>

      // Runs the tests only if there was no fatal failure or skip triggered
      // during global set-up.
<span style = "background-color:#dfd">      if (Test::IsSkipped()) {</span>
        // Emit diagnostics when global set-up calls skip, as it will not be
        // emitted by default.
<span style = "background-color:#fdd">        TestResult&amp; test_result =</span>
            *internal::GetUnitTestImpl()-&gt;current_test_result();
<span style = "background-color:#fdd">        for (int j = 0; j &lt; test_result.total_part_count(); ++j) {
          const TestPartResult&amp; test_part_result =</span>
              test_result.GetTestPartResult(j);
<span style = "background-color:#fdd">          if (test_part_result.type() == TestPartResult::kSkip) {
            const std::string&amp; result = test_part_result.message();
            printf("%s\n", result.c_str());
          }
        }
        fflush(stdout);</span>
<span style = "background-color:#dfd">      } else if (!Test::HasFatalFailure()) {
        for (int test_index = 0; test_index &lt; total_test_suite_count();
             test_index++) {
          GetMutableSuiteCase(test_index)-&gt;Run();
          if (GTEST_FLAG(fail_fast) &amp;&amp;</span>
              GetMutableSuiteCase(test_index)-&gt;Failed()) {
<span style = "background-color:#fdd">            for (int j = test_index + 1; j &lt; total_test_suite_count(); j++) {
              GetMutableSuiteCase(j)-&gt;Skip();
            }
            break;</span>
          }
<span style = "background-color:#dfd">        }
      } else if (Test::HasFatalFailure()) {</span>
        // If there was a fatal failure during the global setup then we know we
        // aren't going to run any tests. Explicitly mark all of the tests as
        // skipped to make this obvious in the output.
<span style = "background-color:#fdd">        for (int test_index = 0; test_index &lt; total_test_suite_count();
             test_index++) {
          GetMutableSuiteCase(test_index)-&gt;Skip();
        }</span>
      }

      // Tears down all environments in reverse order afterwards.
<span style = "background-color:#dfd">      repeater-&gt;OnEnvironmentsTearDownStart(*parent_);
      std::for_each(environments_.rbegin(), environments_.rend(),</span>
                    TearDownEnvironment);
<span style = "background-color:#dfd">      repeater-&gt;OnEnvironmentsTearDownEnd(*parent_);</span>
    }

<span style = "background-color:#dfd">    elapsed_time_ = timer.Elapsed();</span>

    // Tells the unit test event listener that the tests have just finished.
<span style = "background-color:#dfd">    repeater-&gt;OnTestIterationEnd(*parent_, i);</span>

    // Gets the result and clears it.
<span style = "background-color:#dfd">    if (!Passed()) {</span>
<span style = "background-color:#fdd">      failed = true;</span>
    }

    // Restores the original test order after the iteration.  This
    // allows the user to quickly repro a failure that happens in the
    // N-th iteration without repeating the first (N - 1) iterations.
    // This is not enclosed in "if (GTEST_FLAG(shuffle)) { ... }", in
    // case the user somehow changes the value of the flag somewhere
    // (it's always safe to unshuffle the tests).
<span style = "background-color:#dfd">    UnshuffleTests();</span>

<span style = "background-color:#dfd">    if (GTEST_FLAG(shuffle)) {</span>
      // Picks a new random seed for each iteration.
<span style = "background-color:#fdd">      random_seed_ = GetNextRandomSeed(random_seed_);</span>
    }
<span style = "background-color:#dfd">  }</span>

<span style = "background-color:#dfd">  repeater-&gt;OnTestProgramEnd(*parent_);</span>

<span style = "background-color:#dfd">  if (!gtest_is_initialized_before_run_all_tests) {</span>
<span style = "background-color:#fdd">    ColoredPrintf(</span>
        GTestColor::kRed,
        "\nIMPORTANT NOTICE - DO NOT IGNORE:\n"
        "This test program did NOT call " GTEST_INIT_GOOGLE_TEST_NAME_
        "() before calling RUN_ALL_TESTS(). This is INVALID. Soon " GTEST_NAME_
        " will start to enforce the valid usage. "
        "Please fix it ASAP, or IT WILL START TO FAIL.\n");  // NOLINT
#if GTEST_FOR_GOOGLE_
    ColoredPrintf(GTestColor::kRed,
                  "For more details, see http://wiki/Main/ValidGUnitMain.\n");
#endif  // GTEST_FOR_GOOGLE_
  }

<span style = "background-color:#dfd">  return !failed;
}</span>

// Reads the GTEST_SHARD_STATUS_FILE environment variable, and creates the file
// if the variable is present. If a file already exists at this location, this
// function will write over it. If the variable is present, but the file cannot
// be created, prints an error and exits.
<span style = "background-color:#dfd">void WriteToShardStatusFileIfNeeded() {
  const char* const test_shard_file = posix::GetEnv(kTestShardStatusFile);
  if (test_shard_file != nullptr) {</span>
<span style = "background-color:#fdd">    FILE* const file = posix::FOpen(test_shard_file, "w");
    if (file == nullptr) {
      ColoredPrintf(GTestColor::kRed,</span>
                    "Could not write to the test shard status file \"%s\" "
                    "specified by the %s environment variable.\n",
                    test_shard_file, kTestShardStatusFile);
<span style = "background-color:#fdd">      fflush(stdout);
      exit(EXIT_FAILURE);</span>
    }
<span style = "background-color:#fdd">    fclose(file);</span>
  }
<span style = "background-color:#dfd">}</span>

// Checks whether sharding is enabled by examining the relevant
// environment variable values. If the variables are present,
// but inconsistent (i.e., shard_index &gt;= total_shards), prints
// an error and exits. If in_subprocess_for_death_test, sharding is
// disabled because it must only be applied to the original test
// process. Otherwise, we could filter out death tests we intended to execute.
bool ShouldShard(const char* total_shards_env,
                 const char* shard_index_env,
<span style = "background-color:#dfd">                 bool in_subprocess_for_death_test) {
  if (in_subprocess_for_death_test) {</span>
<span style = "background-color:#fdd">    return false;</span>
  }

<span style = "background-color:#dfd">  const int32_t total_shards = Int32FromEnvOrDie(total_shards_env, -1);
  const int32_t shard_index = Int32FromEnvOrDie(shard_index_env, -1);</span>

<span style = "background-color:#dfd">  if (total_shards == -1 &amp;&amp; shard_index == -1) {
    return false;</span>
<span style = "background-color:#fdd">  } else if (total_shards == -1 &amp;&amp; shard_index != -1) {
    const Message msg = Message()</span>
      &lt;&lt; "Invalid environment variables: you have "
      &lt;&lt; kTestShardIndex &lt;&lt; " = " &lt;&lt; shard_index
      &lt;&lt; ", but have left " &lt;&lt; kTestTotalShards &lt;&lt; " unset.\n";
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    fflush(stdout);
    exit(EXIT_FAILURE);
  } else if (total_shards != -1 &amp;&amp; shard_index == -1) {
    const Message msg = Message()</span>
      &lt;&lt; "Invalid environment variables: you have "
      &lt;&lt; kTestTotalShards &lt;&lt; " = " &lt;&lt; total_shards
      &lt;&lt; ", but have left " &lt;&lt; kTestShardIndex &lt;&lt; " unset.\n";
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    fflush(stdout);
    exit(EXIT_FAILURE);
  } else if (shard_index &lt; 0 || shard_index &gt;= total_shards) {
    const Message msg = Message()</span>
      &lt;&lt; "Invalid environment variables: we require 0 &lt;= "
      &lt;&lt; kTestShardIndex &lt;&lt; " &lt; " &lt;&lt; kTestTotalShards
      &lt;&lt; ", but you have " &lt;&lt; kTestShardIndex &lt;&lt; "=" &lt;&lt; shard_index
      &lt;&lt; ", " &lt;&lt; kTestTotalShards &lt;&lt; "=" &lt;&lt; total_shards &lt;&lt; ".\n";
<span style = "background-color:#fdd">    ColoredPrintf(GTestColor::kRed, "%s", msg.GetString().c_str());
    fflush(stdout);
    exit(EXIT_FAILURE);
  }</span>

<span style = "background-color:#fdd">  return total_shards &gt; 1;</span>
<span style = "background-color:#dfd">}</span>

// Parses the environment variable var as an Int32. If it is unset,
// returns default_val. If it is not an Int32, prints an error
// and aborts.
<span style = "background-color:#dfd">int32_t Int32FromEnvOrDie(const char* var, int32_t default_val) {
  const char* str_val = posix::GetEnv(var);
  if (str_val == nullptr) {
    return default_val;</span>
  }

  int32_t result;
<span style = "background-color:#fdd">  if (!ParseInt32(Message() &lt;&lt; "The value of environment variable " &lt;&lt; var,</span>
                  str_val, &amp;result)) {
<span style = "background-color:#fdd">    exit(EXIT_FAILURE);</span>
  }
<span style = "background-color:#fdd">  return result;</span>
<span style = "background-color:#dfd">}</span>

// Given the total number of shards, the shard index, and the test id,
// returns true if and only if the test should be run on this shard. The test id
// is some arbitrary but unique non-negative integer assigned to each test
// method. Assumes that 0 &lt;= shard_index &lt; total_shards.
<span style = "background-color:#fdd">bool ShouldRunTestOnShard(int total_shards, int shard_index, int test_id) {
  return (test_id % total_shards) == shard_index;
}</span>

// Compares the name of each test with the user-specified filter to
// decide whether the test should be run, then records the result in
// each TestSuite and TestInfo object.
// If shard_tests == true, further filters tests based on sharding
// variables in the environment - see
// https://github.com/google/googletest/blob/master/googletest/docs/advanced.md
// . Returns the number of tests that should run.
<span style = "background-color:#dfd">int UnitTestImpl::FilterTests(ReactionToSharding shard_tests) {
  const int32_t total_shards = shard_tests == HONOR_SHARDING_PROTOCOL ?</span>
      Int32FromEnvOrDie(kTestTotalShards, -1) : -1;
<span style = "background-color:#dfd">  const int32_t shard_index = shard_tests == HONOR_SHARDING_PROTOCOL ?</span>
      Int32FromEnvOrDie(kTestShardIndex, -1) : -1;

  // num_runnable_tests are the number of tests that will
  // run across all shards (i.e., match filter and are not disabled).
  // num_selected_tests are the number of tests to be run on
  // this shard.
<span style = "background-color:#dfd">  int num_runnable_tests = 0;
  int num_selected_tests = 0;
  for (auto* test_suite : test_suites_) {
    const std::string&amp; test_suite_name = test_suite-&gt;name();
    test_suite-&gt;set_should_run(false);</span>

<span style = "background-color:#dfd">    for (size_t j = 0; j &lt; test_suite-&gt;test_info_list().size(); j++) {
      TestInfo* const test_info = test_suite-&gt;test_info_list()[j];
      const std::string test_name(test_info-&gt;name());</span>
      // A test is disabled if test suite name or test name matches
      // kDisableTestFilter.
<span style = "background-color:#dfd">      const bool is_disabled = internal::UnitTestOptions::MatchesFilter(</span>
                                   test_suite_name, kDisableTestFilter) ||
                               internal::UnitTestOptions::MatchesFilter(
                                   test_name, kDisableTestFilter);
<span style = "background-color:#dfd">      test_info-&gt;is_disabled_ = is_disabled;</span>

<span style = "background-color:#dfd">      const bool matches_filter = internal::UnitTestOptions::FilterMatchesTest(</span>
          test_suite_name, test_name);
<span style = "background-color:#dfd">      test_info-&gt;matches_filter_ = matches_filter;</span>

<span style = "background-color:#dfd">      const bool is_runnable =</span>
          (GTEST_FLAG(also_run_disabled_tests) || !is_disabled) &amp;&amp;
          matches_filter;

<span style = "background-color:#dfd">      const bool is_in_another_shard =</span>
          shard_tests != IGNORE_SHARDING_PROTOCOL &amp;&amp;
          !ShouldRunTestOnShard(total_shards, shard_index, num_runnable_tests);
<span style = "background-color:#dfd">      test_info-&gt;is_in_another_shard_ = is_in_another_shard;
      const bool is_selected = is_runnable &amp;&amp; !is_in_another_shard;</span>

<span style = "background-color:#dfd">      num_runnable_tests += is_runnable;
      num_selected_tests += is_selected;</span>

<span style = "background-color:#dfd">      test_info-&gt;should_run_ = is_selected;
      test_suite-&gt;set_should_run(test_suite-&gt;should_run() || is_selected);
    }
  }
  return num_selected_tests;
}</span>

// Prints the given C-string on a single line by replacing all '\n'
// characters with string "\\n".  If the output takes more than
// max_length characters, only prints the first max_length characters
// and "...".
<span style = "background-color:#fdd">static void PrintOnOneLine(const char* str, int max_length) {
  if (str != nullptr) {
    for (int i = 0; *str != '\0'; ++str) {
      if (i &gt;= max_length) {
        printf("...");
        break;</span>
      }
<span style = "background-color:#fdd">      if (*str == '\n') {
        printf("\\n");
        i += 2;
      } else {
        printf("%c", *str);
        ++i;</span>
      }
<span style = "background-color:#fdd">    }</span>
  }
<span style = "background-color:#fdd">}</span>

// Prints the names of the tests matching the user-specified filter flag.
<span style = "background-color:#fdd">void UnitTestImpl::ListTestsMatchingFilter() {</span>
  // Print at most this many characters for each type/value parameter.
<span style = "background-color:#fdd">  const int kMaxParamLength = 250;</span>

<span style = "background-color:#fdd">  for (auto* test_suite : test_suites_) {
    bool printed_test_suite_name = false;</span>

<span style = "background-color:#fdd">    for (size_t j = 0; j &lt; test_suite-&gt;test_info_list().size(); j++) {
      const TestInfo* const test_info = test_suite-&gt;test_info_list()[j];
      if (test_info-&gt;matches_filter_) {
        if (!printed_test_suite_name) {
          printed_test_suite_name = true;
          printf("%s.", test_suite-&gt;name());
          if (test_suite-&gt;type_param() != nullptr) {
            printf("  # %s = ", kTypeParamLabel);</span>
            // We print the type parameter on a single line to make
            // the output easy to parse by a program.
<span style = "background-color:#fdd">            PrintOnOneLine(test_suite-&gt;type_param(), kMaxParamLength);</span>
          }
<span style = "background-color:#fdd">          printf("\n");</span>
        }
<span style = "background-color:#fdd">        printf("  %s", test_info-&gt;name());
        if (test_info-&gt;value_param() != nullptr) {
          printf("  # %s = ", kValueParamLabel);</span>
          // We print the value parameter on a single line to make the
          // output easy to parse by a program.
<span style = "background-color:#fdd">          PrintOnOneLine(test_info-&gt;value_param(), kMaxParamLength);</span>
        }
<span style = "background-color:#fdd">        printf("\n");</span>
      }
<span style = "background-color:#fdd">    }
  }
  fflush(stdout);
  const std::string&amp; output_format = UnitTestOptions::GetOutputFormat();
  if (output_format == "xml" || output_format == "json") {
    FILE* fileout = OpenFileForWriting(</span>
        UnitTestOptions::GetAbsolutePathToOutputFile().c_str());
<span style = "background-color:#fdd">    std::stringstream stream;
    if (output_format == "xml") {
      XmlUnitTestResultPrinter(</span>
          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())
          .PrintXmlTestsList(&amp;stream, test_suites_);
<span style = "background-color:#fdd">    } else if (output_format == "json") {
      JsonUnitTestResultPrinter(</span>
          UnitTestOptions::GetAbsolutePathToOutputFile().c_str())
          .PrintJsonTestList(&amp;stream, test_suites_);
    }
<span style = "background-color:#fdd">    fprintf(fileout, "%s", StringStreamToString(&amp;stream).c_str());
    fclose(fileout);
  }
}</span>

// Sets the OS stack trace getter.
//
// Does nothing if the input and the current OS stack trace getter are
// the same; otherwise, deletes the old getter and makes the input the
// current getter.
void UnitTestImpl::set_os_stack_trace_getter(
<span style = "background-color:#fdd">    OsStackTraceGetterInterface* getter) {
  if (os_stack_trace_getter_ != getter) {
    delete os_stack_trace_getter_;
    os_stack_trace_getter_ = getter;</span>
  }
<span style = "background-color:#fdd">}</span>

// Returns the current OS stack trace getter if it is not NULL;
// otherwise, creates an OsStackTraceGetter, makes it the current
// getter, and returns it.
<span style = "background-color:#dfd">OsStackTraceGetterInterface* UnitTestImpl::os_stack_trace_getter() {
  if (os_stack_trace_getter_ == nullptr) {</span>
#ifdef GTEST_OS_STACK_TRACE_GETTER_
    os_stack_trace_getter_ = new GTEST_OS_STACK_TRACE_GETTER_;
#else
<span style = "background-color:#dfd">    os_stack_trace_getter_ = new OsStackTraceGetter;</span>
#endif  // GTEST_OS_STACK_TRACE_GETTER_
  }

<span style = "background-color:#dfd">  return os_stack_trace_getter_;
}</span>

// Returns the most specific TestResult currently running.
<span style = "background-color:#dfd">TestResult* UnitTestImpl::current_test_result() {
  if (current_test_info_ != nullptr) {
    return &amp;current_test_info_-&gt;result_;</span>
  }
<span style = "background-color:#dfd">  if (current_test_suite_ != nullptr) {</span>
<span style = "background-color:#fdd">    return &amp;current_test_suite_-&gt;ad_hoc_test_result_;</span>
  }
<span style = "background-color:#dfd">  return &amp;ad_hoc_test_result_;
}</span>

// Shuffles all test suites, and the tests within each test suite,
// making sure that death tests are still run first.
<span style = "background-color:#fdd">void UnitTestImpl::ShuffleTests() {</span>
  // Shuffles the death test suites.
<span style = "background-color:#fdd">  ShuffleRange(random(), 0, last_death_test_suite_ + 1, &amp;test_suite_indices_);</span>

  // Shuffles the non-death test suites.
<span style = "background-color:#fdd">  ShuffleRange(random(), last_death_test_suite_ + 1,</span>
               static_cast&lt;int&gt;(test_suites_.size()), &amp;test_suite_indices_);

  // Shuffles the tests inside each test suite.
<span style = "background-color:#fdd">  for (auto&amp; test_suite : test_suites_) {
    test_suite-&gt;ShuffleTests(random());
  }
}</span>

// Restores the test suites and tests to their order before the first shuffle.
<span style = "background-color:#dfd">void UnitTestImpl::UnshuffleTests() {
  for (size_t i = 0; i &lt; test_suites_.size(); i++) {</span>
    // Unshuffles the tests in each test suite.
<span style = "background-color:#dfd">    test_suites_[i]-&gt;UnshuffleTests();</span>
    // Resets the index of each test suite.
<span style = "background-color:#dfd">    test_suite_indices_[i] = static_cast&lt;int&gt;(i);
  }
}</span>

// Returns the current OS stack trace as an std::string.
//
// The maximum number of stack frames to be included is specified by
// the gtest_stack_trace_depth flag.  The skip_count parameter
// specifies the number of top frames to be skipped, which doesn't
// count against the number of frames to be included.
//
// For example, if Foo() calls Bar(), which in turn calls
// GetCurrentOsStackTraceExceptTop(..., 1), Foo() will be included in
// the trace but Bar() and GetCurrentOsStackTraceExceptTop() won't.
std::string GetCurrentOsStackTraceExceptTop(UnitTest* /*unit_test*/,
<span style = "background-color:#fdd">                                            int skip_count) {</span>
  // We pass skip_count + 1 to skip this wrapper function in addition
  // to what the user really wants to skip.
<span style = "background-color:#fdd">  return GetUnitTestImpl()-&gt;CurrentOsStackTraceExceptTop(skip_count + 1);
}</span>

// Used by the GTEST_SUPPRESS_UNREACHABLE_CODE_WARNING_BELOW_ macro to
// suppress unreachable code warnings.
namespace {
class ClassUniqueToAlwaysTrue {};
}

<span style = "background-color:#dfd">bool IsTrue(bool condition) { return condition; }</span>

<span style = "background-color:#dfd">bool AlwaysTrue() {</span>
#if GTEST_HAS_EXCEPTIONS
  // This condition is always false so AlwaysTrue() never actually throws,
  // but it makes the compiler think that it may throw.
<span style = "background-color:#dfd">  if (IsTrue(false))</span>
<span style = "background-color:#fdd">    throw ClassUniqueToAlwaysTrue();</span>
#endif  // GTEST_HAS_EXCEPTIONS
<span style = "background-color:#dfd">  return true;
}</span>

// If *pstr starts with the given prefix, modifies *pstr to be right
// past the prefix and returns true; otherwise leaves *pstr unchanged
// and returns false.  None of pstr, *pstr, and prefix can be NULL.
<span style = "background-color:#fdd">bool SkipPrefix(const char* prefix, const char** pstr) {
  const size_t prefix_len = strlen(prefix);
  if (strncmp(*pstr, prefix, prefix_len) == 0) {
    *pstr += prefix_len;
    return true;</span>
  }
<span style = "background-color:#fdd">  return false;
}</span>

// Parses a string as a command line flag.  The string should have
// the format "--flag=value".  When def_optional is true, the "=value"
// part can be omitted.
//
// Returns the value of the flag, or NULL if the parsing failed.
static const char* ParseFlagValue(const char* str, const char* flag,
<span style = "background-color:#fdd">                                  bool def_optional) {</span>
  // str and flag must not be NULL.
<span style = "background-color:#fdd">  if (str == nullptr || flag == nullptr) return nullptr;</span>

  // The flag must start with "--" followed by GTEST_FLAG_PREFIX_.
<span style = "background-color:#fdd">  const std::string flag_str = std::string("--") + GTEST_FLAG_PREFIX_ + flag;
  const size_t flag_len = flag_str.length();
  if (strncmp(str, flag_str.c_str(), flag_len) != 0) return nullptr;</span>

  // Skips the flag name.
<span style = "background-color:#fdd">  const char* flag_end = str + flag_len;</span>

  // When def_optional is true, it's OK to not have a "=value" part.
<span style = "background-color:#fdd">  if (def_optional &amp;&amp; (flag_end[0] == '\0')) {
    return flag_end;</span>
  }

  // If def_optional is true and there are more characters after the
  // flag name, or if def_optional is false, there must be a '=' after
  // the flag name.
<span style = "background-color:#fdd">  if (flag_end[0] != '=') return nullptr;</span>

  // Returns the string after "=".
<span style = "background-color:#fdd">  return flag_end + 1;
}</span>

// Parses a string for a bool flag, in the form of either
// "--flag=value" or "--flag".
//
// In the former case, the value is taken as true as long as it does
// not start with '0', 'f', or 'F'.
//
// In the latter case, the value is taken as true.
//
// On success, stores the value of the flag in *value, and returns
// true.  On failure, returns false without changing *value.
<span style = "background-color:#fdd">static bool ParseBoolFlag(const char* str, const char* flag, bool* value) {</span>
  // Gets the value of the flag as a string.
<span style = "background-color:#fdd">  const char* const value_str = ParseFlagValue(str, flag, true);</span>

  // Aborts if the parsing failed.
<span style = "background-color:#fdd">  if (value_str == nullptr) return false;</span>

  // Converts the string value to a bool.
<span style = "background-color:#fdd">  *value = !(*value_str == '0' || *value_str == 'f' || *value_str == 'F');
  return true;
}</span>

// Parses a string for an int32_t flag, in the form of "--flag=value".
//
// On success, stores the value of the flag in *value, and returns
// true.  On failure, returns false without changing *value.
<span style = "background-color:#fdd">bool ParseInt32Flag(const char* str, const char* flag, int32_t* value) {</span>
  // Gets the value of the flag as a string.
<span style = "background-color:#fdd">  const char* const value_str = ParseFlagValue(str, flag, false);</span>

  // Aborts if the parsing failed.
<span style = "background-color:#fdd">  if (value_str == nullptr) return false;</span>

  // Sets *value to the value of the flag.
<span style = "background-color:#fdd">  return ParseInt32(Message() &lt;&lt; "The value of flag --" &lt;&lt; flag,</span>
                    value_str, value);
<span style = "background-color:#fdd">}</span>

// Parses a string for a string flag, in the form of "--flag=value".
//
// On success, stores the value of the flag in *value, and returns
// true.  On failure, returns false without changing *value.
template &lt;typename String&gt;
<span style = "background-color:#fdd">static bool ParseStringFlag(const char* str, const char* flag, String* value) {</span>
  // Gets the value of the flag as a string.
<span style = "background-color:#fdd">  const char* const value_str = ParseFlagValue(str, flag, false);</span>

  // Aborts if the parsing failed.
<span style = "background-color:#fdd">  if (value_str == nullptr) return false;</span>

  // Sets *value to the value of the flag.
<span style = "background-color:#fdd">  *value = value_str;
  return true;
}</span>

// Determines whether a string has a prefix that Google Test uses for its
// flags, i.e., starts with GTEST_FLAG_PREFIX_ or GTEST_FLAG_PREFIX_DASH_.
// If Google Test detects that a command line flag has its prefix but is not
// recognized, it will print its help message. Flags starting with
// GTEST_INTERNAL_PREFIX_ followed by "internal_" are considered Google Test
// internal flags and do not trigger the help message.
<span style = "background-color:#fdd">static bool HasGoogleTestFlagPrefix(const char* str) {
  return (SkipPrefix("--", &amp;str) ||</span>
          SkipPrefix("-", &amp;str) ||
          SkipPrefix("/", &amp;str)) &amp;&amp;
         !SkipPrefix(GTEST_FLAG_PREFIX_ "internal_", &amp;str) &amp;&amp;
         (SkipPrefix(GTEST_FLAG_PREFIX_, &amp;str) ||
          SkipPrefix(GTEST_FLAG_PREFIX_DASH_, &amp;str));
<span style = "background-color:#fdd">}</span>

// Prints a string containing code-encoded text.  The following escape
// sequences can be used in the string to control the text color:
//
//   @@    prints a single '@' character.
//   @R    changes the color to red.
//   @G    changes the color to green.
//   @Y    changes the color to yellow.
//   @D    changes to the default terminal text color.
//
<span style = "background-color:#fdd">static void PrintColorEncoded(const char* str) {
  GTestColor color = GTestColor::kDefault;  // The current color.</span>

  // Conceptually, we split the string into segments divided by escape
  // sequences.  Then we print one segment at a time.  At the end of
  // each iteration, the str pointer advances to the beginning of the
  // next segment.
  for (;;) {
<span style = "background-color:#fdd">    const char* p = strchr(str, '@');
    if (p == nullptr) {
      ColoredPrintf(color, "%s", str);
      return;</span>
    }

<span style = "background-color:#fdd">    ColoredPrintf(color, "%s", std::string(str, p).c_str());</span>

<span style = "background-color:#fdd">    const char ch = p[1];
    str = p + 2;
    if (ch == '@') {
      ColoredPrintf(color, "@");
    } else if (ch == 'D') {
      color = GTestColor::kDefault;
    } else if (ch == 'R') {
      color = GTestColor::kRed;
    } else if (ch == 'G') {
      color = GTestColor::kGreen;
    } else if (ch == 'Y') {
      color = GTestColor::kYellow;
    } else {
      --str;</span>
    }
<span style = "background-color:#fdd">  }
}</span>

static const char kColorEncodedHelpMessage[] =
    "This program contains tests written using " GTEST_NAME_
    ". You can use the\n"
    "following command line flags to control its behavior:\n"
    "\n"
    "Test Selection:\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "list_tests@D\n"
    "      List the names of all tests instead of running them. The name of\n"
    "      TEST(Foo, Bar) is \"Foo.Bar\".\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "filter=@YPOSITIVE_PATTERNS"
    "[@G-@YNEGATIVE_PATTERNS]@D\n"
    "      Run only the tests whose name matches one of the positive patterns "
    "but\n"
    "      none of the negative patterns. '?' matches any single character; "
    "'*'\n"
    "      matches any substring; ':' separates two patterns.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "also_run_disabled_tests@D\n"
    "      Run all disabled tests too.\n"
    "\n"
    "Test Execution:\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "repeat=@Y[COUNT]@D\n"
    "      Run the tests repeatedly; use a negative count to repeat forever.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "shuffle@D\n"
    "      Randomize tests' orders on every iteration.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "random_seed=@Y[NUMBER]@D\n"
    "      Random number seed to use for shuffling test orders (between 1 and\n"
    "      99999, or 0 to use a seed based on the current time).\n"
    "\n"
    "Test Output:\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "color=@Y(@Gyes@Y|@Gno@Y|@Gauto@Y)@D\n"
    "      Enable/disable colored output. The default is @Gauto@D.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "brief=1@D\n"
    "      Only print test failures.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "print_time=0@D\n"
    "      Don't print the elapsed time of each test.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "output=@Y(@Gjson@Y|@Gxml@Y)[@G:@YDIRECTORY_PATH@G" GTEST_PATH_SEP_
    "@Y|@G:@YFILE_PATH]@D\n"
    "      Generate a JSON or XML report in the given directory or with the "
    "given\n"
    "      file name. @YFILE_PATH@D defaults to @Gtest_detail.xml@D.\n"
# if GTEST_CAN_STREAM_RESULTS_
    "  @G--" GTEST_FLAG_PREFIX_
    "stream_result_to=@YHOST@G:@YPORT@D\n"
    "      Stream test results to the given server.\n"
# endif  // GTEST_CAN_STREAM_RESULTS_
    "\n"
    "Assertion Behavior:\n"
# if GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS
    "  @G--" GTEST_FLAG_PREFIX_
    "death_test_style=@Y(@Gfast@Y|@Gthreadsafe@Y)@D\n"
    "      Set the default death test style.\n"
# endif  // GTEST_HAS_DEATH_TEST &amp;&amp; !GTEST_OS_WINDOWS
    "  @G--" GTEST_FLAG_PREFIX_
    "break_on_failure@D\n"
    "      Turn assertion failures into debugger break-points.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "throw_on_failure@D\n"
    "      Turn assertion failures into C++ exceptions for use by an external\n"
    "      test framework.\n"
    "  @G--" GTEST_FLAG_PREFIX_
    "catch_exceptions=0@D\n"
    "      Do not report exceptions as test failures. Instead, allow them\n"
    "      to crash the program or throw a pop-up (on Windows).\n"
    "\n"
    "Except for @G--" GTEST_FLAG_PREFIX_
    "list_tests@D, you can alternatively set "
    "the corresponding\n"
    "environment variable of a flag (all letters in upper-case). For example, "
    "to\n"
    "disable colored text output, you can either specify "
    "@G--" GTEST_FLAG_PREFIX_
    "color=no@D or set\n"
    "the @G" GTEST_FLAG_PREFIX_UPPER_
    "COLOR@D environment variable to @Gno@D.\n"
    "\n"
    "For more information, please read the " GTEST_NAME_
    " documentation at\n"
    "@G" GTEST_PROJECT_URL_ "@D. If you find a bug in " GTEST_NAME_
    "\n"
    "(not one in your own code or tests), please report it to\n"
    "@G&lt;" GTEST_DEV_EMAIL_ "&gt;@D.\n";

<span style = "background-color:#fdd">static bool ParseGoogleTestFlag(const char* const arg) {
  return ParseBoolFlag(arg, kAlsoRunDisabledTestsFlag,</span>
                       &amp;GTEST_FLAG(also_run_disabled_tests)) ||
         ParseBoolFlag(arg, kBreakOnFailureFlag,
                       &amp;GTEST_FLAG(break_on_failure)) ||
         ParseBoolFlag(arg, kCatchExceptionsFlag,
                       &amp;GTEST_FLAG(catch_exceptions)) ||
         ParseStringFlag(arg, kColorFlag, &amp;GTEST_FLAG(color)) ||
         ParseStringFlag(arg, kDeathTestStyleFlag,
                         &amp;GTEST_FLAG(death_test_style)) ||
         ParseBoolFlag(arg, kDeathTestUseFork,
                       &amp;GTEST_FLAG(death_test_use_fork)) ||
         ParseBoolFlag(arg, kFailFast, &amp;GTEST_FLAG(fail_fast)) ||
         ParseStringFlag(arg, kFilterFlag, &amp;GTEST_FLAG(filter)) ||
         ParseStringFlag(arg, kInternalRunDeathTestFlag,
                         &amp;GTEST_FLAG(internal_run_death_test)) ||
         ParseBoolFlag(arg, kListTestsFlag, &amp;GTEST_FLAG(list_tests)) ||
         ParseStringFlag(arg, kOutputFlag, &amp;GTEST_FLAG(output)) ||
         ParseBoolFlag(arg, kBriefFlag, &amp;GTEST_FLAG(brief)) ||
         ParseBoolFlag(arg, kPrintTimeFlag, &amp;GTEST_FLAG(print_time)) ||
         ParseBoolFlag(arg, kPrintUTF8Flag, &amp;GTEST_FLAG(print_utf8)) ||
         ParseInt32Flag(arg, kRandomSeedFlag, &amp;GTEST_FLAG(random_seed)) ||
         ParseInt32Flag(arg, kRepeatFlag, &amp;GTEST_FLAG(repeat)) ||
         ParseBoolFlag(arg, kShuffleFlag, &amp;GTEST_FLAG(shuffle)) ||
         ParseInt32Flag(arg, kStackTraceDepthFlag,
                        &amp;GTEST_FLAG(stack_trace_depth)) ||
         ParseStringFlag(arg, kStreamResultToFlag,
                         &amp;GTEST_FLAG(stream_result_to)) ||
         ParseBoolFlag(arg, kThrowOnFailureFlag, &amp;GTEST_FLAG(throw_on_failure));
<span style = "background-color:#fdd">}</span>

#if GTEST_USE_OWN_FLAGFILE_FLAG_
<span style = "background-color:#fdd">static void LoadFlagsFromFile(const std::string&amp; path) {
  FILE* flagfile = posix::FOpen(path.c_str(), "r");
  if (!flagfile) {
    GTEST_LOG_(FATAL) &lt;&lt; "Unable to open file \"" &lt;&lt; GTEST_FLAG(flagfile)</span>
                      &lt;&lt; "\"";
  }
<span style = "background-color:#fdd">  std::string contents(ReadEntireFile(flagfile));
  posix::FClose(flagfile);
  std::vector&lt;std::string&gt; lines;
  SplitString(contents, '\n', &amp;lines);
  for (size_t i = 0; i &lt; lines.size(); ++i) {
    if (lines[i].empty())
      continue;
    if (!ParseGoogleTestFlag(lines[i].c_str()))
      g_help_flag = true;
  }
}</span>
#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_

// Parses the command line for Google Test flags, without initializing
// other parts of Google Test.  The type parameter CharType can be
// instantiated to either char or wchar_t.
template &lt;typename CharType&gt;
<span style = "background-color:#dfd">void ParseGoogleTestFlagsOnlyImpl(int* argc, CharType** argv) {
  for (int i = 1; i &lt; *argc; i++) {</span>
<span style = "background-color:#fdd">    const std::string arg_string = StreamableToString(argv[i]);
    const char* const arg = arg_string.c_str();</span>

    using internal::ParseBoolFlag;
    using internal::ParseInt32Flag;
    using internal::ParseStringFlag;

<span style = "background-color:#fdd">    bool remove_flag = false;
    if (ParseGoogleTestFlag(arg)) {
      remove_flag = true;</span>
#if GTEST_USE_OWN_FLAGFILE_FLAG_
<span style = "background-color:#fdd">    } else if (ParseStringFlag(arg, kFlagfileFlag, &amp;GTEST_FLAG(flagfile))) {
      LoadFlagsFromFile(GTEST_FLAG(flagfile));
      remove_flag = true;</span>
#endif  // GTEST_USE_OWN_FLAGFILE_FLAG_
<span style = "background-color:#fdd">    } else if (arg_string == "--help" || arg_string == "-h" ||
               arg_string == "-?" || arg_string == "/?" ||</span>
               HasGoogleTestFlagPrefix(arg)) {
      // Both help flag and unrecognized Google Test flags (excluding
      // internal ones) trigger help display.
<span style = "background-color:#fdd">      g_help_flag = true;</span>
    }

<span style = "background-color:#fdd">    if (remove_flag) {</span>
      // Shift the remainder of the argv list left by one.  Note
      // that argv has (*argc + 1) elements, the last one always being
      // NULL.  The following loop moves the trailing NULL element as
      // well.
<span style = "background-color:#fdd">      for (int j = i; j != *argc; j++) {
        argv[j] = argv[j + 1];
      }</span>

      // Decrements the argument count.
<span style = "background-color:#fdd">      (*argc)--;</span>

      // We also need to decrement the iterator as we just removed
      // an element.
<span style = "background-color:#fdd">      i--;</span>
    }
<span style = "background-color:#fdd">  }</span>

<span style = "background-color:#dfd">  if (g_help_flag) {</span>
    // We print the help here instead of in RUN_ALL_TESTS(), as the
    // latter may not be called at all if the user is using Google
    // Test with another testing framework.
<span style = "background-color:#fdd">    PrintColorEncoded(kColorEncodedHelpMessage);</span>
  }
<span style = "background-color:#dfd">}</span>

// Parses the command line for Google Test flags, without initializing
// other parts of Google Test.
<span style = "background-color:#dfd">void ParseGoogleTestFlagsOnly(int* argc, char** argv) {
  ParseGoogleTestFlagsOnlyImpl(argc, argv);</span>

  // Fix the value of *_NSGetArgc() on macOS, but if and only if
  // *_NSGetArgv() == argv
  // Only applicable to char** version of argv
#if GTEST_OS_MAC
#ifndef GTEST_OS_IOS
  if (*_NSGetArgv() == argv) {
    *_NSGetArgc() = *argc;
  }
#endif
#endif
<span style = "background-color:#dfd">}</span>
<span style = "background-color:#fdd">void ParseGoogleTestFlagsOnly(int* argc, wchar_t** argv) {
  ParseGoogleTestFlagsOnlyImpl(argc, argv);
}</span>

// The internal implementation of InitGoogleTest().
//
// The type parameter CharType can be instantiated to either char or
// wchar_t.
template &lt;typename CharType&gt;
<span style = "background-color:#dfd">void InitGoogleTestImpl(int* argc, CharType** argv) {</span>
  // We don't want to run the initialization code twice.
<span style = "background-color:#dfd">  if (GTestIsInitialized()) return;</span>

<span style = "background-color:#dfd">  if (*argc &lt;= 0) return;</span>

<span style = "background-color:#dfd">  g_argvs.clear();
  for (int i = 0; i != *argc; i++) {
    g_argvs.push_back(StreamableToString(argv[i]));
  }</span>

#if GTEST_HAS_ABSL
  absl::InitializeSymbolizer(g_argvs[0].c_str());
#endif  // GTEST_HAS_ABSL

<span style = "background-color:#dfd">  ParseGoogleTestFlagsOnly(argc, argv);
  GetUnitTestImpl()-&gt;PostFlagParsingInit();
}</span>

}  // namespace internal

// Initializes Google Test.  This must be called before calling
// RUN_ALL_TESTS().  In particular, it parses a command line for the
// flags that Google Test recognizes.  Whenever a Google Test flag is
// seen, it is removed from argv, and *argc is decremented.
//
// No value is returned.  Instead, the Google Test flag variables are
// updated.
//
// Calling the function for the second time has no user-visible effect.
<span style = "background-color:#dfd">void InitGoogleTest(int* argc, char** argv) {</span>
#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#dfd">  internal::InitGoogleTestImpl(argc, argv);</span>
#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#dfd">}</span>

// This overloaded version can be used in Windows programs compiled in
// UNICODE mode.
<span style = "background-color:#fdd">void InitGoogleTest(int* argc, wchar_t** argv) {</span>
#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(argc, argv);
#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#fdd">  internal::InitGoogleTestImpl(argc, argv);</span>
#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#fdd">}</span>

// This overloaded version can be used on Arduino/embedded platforms where
// there is no argc/argv.
<span style = "background-color:#fdd">void InitGoogleTest() {</span>
  // Since Arduino doesn't have a command line, fake out the argc/argv arguments
<span style = "background-color:#fdd">  int argc = 1;
  const auto arg0 = "dummy";
  char* argv0 = const_cast&lt;char*&gt;(arg0);
  char** argv = &amp;argv0;</span>

#if defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
  GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_(&amp;argc, argv);
#else  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#fdd">  internal::InitGoogleTestImpl(&amp;argc, argv);</span>
#endif  // defined(GTEST_CUSTOM_INIT_GOOGLE_TEST_FUNCTION_)
<span style = "background-color:#fdd">}</span>

<span style = "background-color:#fdd">std::string TempDir() {</span>
#if defined(GTEST_CUSTOM_TEMPDIR_FUNCTION_)
  return GTEST_CUSTOM_TEMPDIR_FUNCTION_();
#elif GTEST_OS_WINDOWS_MOBILE
  return "\\temp\\";
#elif GTEST_OS_WINDOWS
<span style = "background-color:#fdd">  const char* temp_dir = internal::posix::GetEnv("TEMP");
  if (temp_dir == nullptr || temp_dir[0] == '\0') {
    return "\\temp\\";
  } else if (temp_dir[strlen(temp_dir) - 1] == '\\') {
    return temp_dir;
  } else {
    return std::string(temp_dir) + "\\";</span>
  }
#elif GTEST_OS_LINUX_ANDROID
  const char* temp_dir = internal::posix::GetEnv("TEST_TMPDIR");
  if (temp_dir == nullptr || temp_dir[0] == '\0') {
    return "/data/local/tmp/";
  } else {
    return temp_dir;
  }
#elif GTEST_OS_LINUX
  const char* temp_dir = internal::posix::GetEnv("TEST_TMPDIR");
  if (temp_dir == nullptr || temp_dir[0] == '\0') {
    return "/tmp/";
  } else {
    return temp_dir;
  }
#else
  return "/tmp/";
#endif  // GTEST_OS_WINDOWS_MOBILE
<span style = "background-color:#fdd">}</span>

// Class ScopedTrace

// Pushes the given source file location and message onto a per-thread
// trace stack maintained by Google Test.
<span style = "background-color:#fdd">void ScopedTrace::PushTrace(const char* file, int line, std::string message) {
  internal::TraceInfo trace;
  trace.file = file;
  trace.line = line;
  trace.message.swap(message);</span>

<span style = "background-color:#fdd">  UnitTest::GetInstance()-&gt;PushGTestTrace(trace);
}</span>

// Pops the info pushed by the c'tor.
ScopedTrace::~ScopedTrace()
<span style = "background-color:#fdd">    GTEST_LOCK_EXCLUDED_(&amp;UnitTest::mutex_) {
  UnitTest::GetInstance()-&gt;PopGTestTrace();
}</span>

}  // namespace testing</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>